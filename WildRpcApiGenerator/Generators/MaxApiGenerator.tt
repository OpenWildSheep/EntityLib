<#@ template language="C#" inherits="BaseApiGenerator" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#
	// convert to the RPC TypeInfo name
	string getRpcType(ReflectionMethod.Parameter param)
	{
		return "Type::" + param.elementType + (param.isArray ? "Array" : "");
	}


	// convert to the target language's type
	string getTargetElementType(ReflectionMethod.Parameter param, bool getUnderlyingType = false)
	{
		return param.elementType switch
		{
			{ } when isEnum(param) && !getUnderlyingType => param.elementTypeName,
			ElementType.Invalid => "void*",
			ElementType.Boolean => "bool",
			ElementType.Integer => "int",
			ElementType.Float => "float",
			ElementType.String => "string",
			_ => param.elementType.ToString(),
		};
	}

	// convert to the target language's type
	string getTargetType(ReflectionMethod.Parameter param)
	{
		var elementType = getTargetElementType(param);
		return param.containerType switch
		{
			ContainerType.Array => $"vector<{elementType}>",
			_ => elementType,
		};
	}


	// convert to the Max SDK type
	string getMaxSdkElementType(ReflectionMethod.Parameter param)
	{
		var elementType = getTargetElementType(param);
		return "Max_" + elementType; // fuck it just prefix everything with Max_ --> all types are typedef'd Max-side, even int/float
		/*if (isEnum(param))
		{
			return elementType;
		}
		return param.elementType switch
		{
			ElementType.Boolean or
			ElementType.String or
			ElementType.Vector3 or
			ElementType.Quat => "Max_" + elementType,
			_ => elementType,
		};*/
	}

	bool isMaxSdkPtrType(ReflectionMethod.Parameter param)
	{
		return param.elementType switch
		{
			ElementType.Boolean or 
				ElementType.Integer or
				ElementType.Float => false,
			_ => true
		};
	}

	// convert to the Max SDK type
	string getMaxSdkType(ReflectionMethod.Parameter param)
	{
		var elementType = getMaxSdkElementType(param);
		var star = isMaxSdkPtrType(param) ? "*" : "";
		return param.containerType switch
		{
			ContainerType.Array => $"Tab<{elementType}{star}>",
			_ => elementType,
		};
	}


	// convert to the MaxScript macro language type
	string getMaxScriptElementType(ReflectionMethod.Parameter param, bool forFunctionMap)
	{
		return param.elementType switch
		{
			{ } when isEnum(param) => forFunctionMap
				? $"TYPE_ENUM"
				: $"TYPE_ENUM, enumID::{param.elementTypeName}",
			ElementType.Vector2 => "TYPE_POINT2",
			ElementType.Vector3 => "TYPE_POINT3",
			ElementType.Color => "TYPE_ACOLOR",
			ElementType.String => "TYPE_TSTR",
			_ => $"TYPE_{getTargetElementType(param, true).ToUpper()}",
		};
	}

	// convert to the MaxScript macro language type
	string getMaxScriptType(ReflectionMethod.Parameter param, bool forFunctionMap, bool isInput)
	{
		var suffix = isInput ? "BR" : "BV";
		var elementType = getMaxScriptElementType(param, forFunctionMap);
		return param.containerType switch
		{
			ContainerType.Array => $"{elementType}_TAB_{suffix}",
			_ => param.elementType == ElementType.String
				? $"{elementType}_{suffix}"
				: elementType,
		};
	}


	string inputSignature(ReflectionMethod.Parameter input)
	{
		return $"const {getMaxSdkType(input)}& {input.name}";
	}

	string inputCall(ReflectionMethod.Parameter input)
	{
		var elementType = getTargetElementType(input);
		var underlyingElementType = getTargetElementType(input, true);
		var cast = elementType != underlyingElementType ? $"(const {underlyingElementType}&)" : "";
		return $"Convert<{getTargetElementType(input, true)}>({cast}{input.name})";
	}


	// MaxScript interfaces need a unique ID, generated with gencid.exe (C:\Program Files\Autodesk\3ds Max 2015 SDK\maxsdk\help\gencid.exe)
	// I generated a pool to pick from... if we need more, just generate more and paste here.
	// Or, we could generate on-demand, and cache per manager name or something... whatever, lazy does it.
	string[] maxClassIds =
	{
		"0x305c0bb7, 0x771c603d",
		"0x17da19d2, 0xdb32de6",
		"0x5e03249d, 0x46422728",
		"0x5ab0af8, 0x3e3f34d2",
		"0x47712a98, 0x31d35f00",
		"0x6d1c7b24, 0x23d52515",
		"0x1ff10d33, 0x64c95867",
		"0x5628158a, 0x61f15902",
		"0xaf7136d, 0x631775e9",
		"0x62d469e2, 0x14bd548c",
		"0x14d05004, 0x77dd0d24",
		"0x559a4eb8, 0x6e3c7187",
		"0x7bab34d5, 0x537c1987",
		"0x21bb1af1, 0x38bb4187",
		"0x4a667631, 0x397e50fc",
		"0x6917106b, 0x10ca3e88",
	};

	bool isValid(ReflectionClass @class)
	{
		//return @class.name == "RPCMarshallingTests";
		return @class.name == "CameraManager";
		return true;
	}
#>
/*
RPC bindings for the Wild game.

THIS FILE WAS AUTOGENERATED.
*/

#pragma once
#include "RpcApi.h"

namespace WRPC
{
//
// Enums
//

<#
	foreach (var @enum in reflectionDb.enums)
	{
#>
enum class <#= @enum.name #>
{
<#
		foreach (var (value, name) in @enum.values.Zip(@enum.names))
		{
			if (name.EndsWith("_COUNT")) continue;
#>
	<#= name #> = <#= value #>,
<#
		}
#>
};
typedef int Max_<#= @enum.name #>;

<#
	} // foreach enums
#>

enum class enumID : EnumID
{
<#
	foreach (var @enum in reflectionDb.enums)
	{
#>
	<#= @enum.name #>,
<#
	}
#>
};

inline void AppendEnums(FPInterfaceDesc& _interface)
{
<#
	foreach (var @enum in reflectionDb.enums)
	{
#>
	_interface.AppendEnum(
		(EnumID)enumID::<#= @enum.name #>, <#= @enum.values.Length #>,
<#
		foreach (var (value, name) in @enum.values.Zip(@enum.names))
		{
			//if (name.EndsWith("_COUNT")) continue;
#>
		_M("<#= name #>"), <#= value #>,
<#
		}
#>
	p_end);

<#
	} // foreach enums
#>
}


//
// Managers
//

<#
	// manager classes
	foreach (var (iC, @class) in reflectionDb.classes.Enumerate())
	{
		if (!isValid(@class)) continue;
#>
class <#= @class.name #> : public Manager
{
public:
	<#= @class.name #>(RpcApi& api)
		: Manager(api, {<#= maxClassIds[iC] #>}, _M("<#= @class.name #>"))
	{
		AppendEnums(*this);
		AppendFunctions();
	}

<#
		var validMethods = @class.validMethods
			.Where(m => m.parameters.All(p => p.elementType != ElementType.Position)) // exclude methods with a Position -> can't bind to MaxScript
			.ToArray();

		// manager method signatures
		foreach (var method in @class.methods)
		{
#>
	MethodInvocation _<#= method.name #> = MethodInvocation("<#= @class.name #>", "<#= method.name #>", {<#= method.inputs.join(getRpcType) #>}, {<#= method.outputs.join(getRpcType) #>}); // <#= method.threadSafe ? "" : "non " #>thread-safe
<#
		}
#>

<#
		// manager method wrappers
		foreach (var method in validMethods)
		{
			var inputCalls = method.inputs.join(inputCall);
#>
	auto <#= method.niceName() #>(<#= method.inputs.join(inputSignature) #>)
	{
<#
			if (method.outputs.Length == 0)
			{
#>
		api.Execute(_<#= method.name #>, {<#= inputCalls #>});
<#
			}
			else //if (method.outputs.Length == 1)
			{
#>
		auto result = api.Execute(_<#= method.name #>, {<#= inputCalls #>});
<#
				// some parameters need custom converters
				foreach (var (iO, output) in method.outputs.Enumerate())
				{
					var containerAs = output.containerType == ContainerType.Array ? "Vector" : "Scalar";
					var rpcElementType = getTargetElementType(output, true);
					var maxElementType = getMaxSdkElementType(output);
					var convert = isMaxSdkPtrType(output) ? "ConvertPtr" : "Convert";
#>
		auto <#= output.name #> = <#= convert #><<#= maxElementType #>>(result.GetParameter(<#= iO #>).As<#= containerAs #><<#= rpcElementType #>>());
<#
				}
				var returnValue = method.outputs.Length == 1
					? method.outputs[0].name
					: $"std::make_tuple({method.outputs.joinNames()})";
#>
		return <#= returnValue #>;
<#
			}
#>
	}

<#
		} // method wrappers foreach
#>


	void AppendFunctions()
	{
<#
		// AppendFunction: see https://area.autodesk.com/blogs/the-3ds-max-blog/adding_new_functions_written_in_c_to_maxscript/
		foreach (var (iM, method) in validMethods.Enumerate())
		{
			var returnType = method.outputs.Length switch
			{
				0 => "TYPE_VOID",
				1 => getMaxScriptType(method.outputs[0], false, false),
				_ => "TYPE_OBJECT_TAB",
			};
#>
		AppendFunction(
			<#= iM #>, _M("<#= method.niceName() #>"), 0,
			<#= returnType #>, 0,
			<#= method.inputs.Length #>, // input count
<#
			foreach (var input in method.inputs)
			{
#>
			_M("<#= input.name #>"), 0, <#= getMaxScriptType(input, false, true) #>,
<#
			}
#>
		p_end);

<#
		} // AppendFunction foreach
#>
	}

	BEGIN_FUNCTION_MAP
<#
		foreach (var (iM, method) in validMethods.Enumerate())
		{
			var returnType = method.outputs.Length switch
			{
				0 => "",
				1 => ", " + getMaxScriptType(method.outputs[0], true, false),
				_ => ", " + "TYPE_OBJECT_TAB",
			};

			var inputTypes = method.inputs.join(input => getMaxScriptType(input, true, true));
			if (inputTypes != "") inputTypes = ", " + inputTypes;
#>
		<#= returnType == "" ? "V" : "" #>FN_<#= method.inputs.Length #>(<#= iM #><#= returnType #>, <#= method.niceName() #><#= inputTypes #>)
<#
		} // FUNCTION_MAP foreach
#>
	END_FUNCTION_MAP
};

<#
	} // foreach manager
#>

//
// API
//

class RpcApiWild : RpcApi
{
public:
	RpcApiWild(Connection& _connection) : RpcApi(_connection) { }

<#
	// manager instances
	foreach (var @class in reflectionDb.classes)
	{
		if (!isValid(@class)) continue;
		var memberName = @class.name.Replace("Manager", "").ToLowerFirstLetter();
		memberName = memberName.Replace("rPC", "rpc");
#>
	<#= @class.name #> <#= memberName #> = <#= @class.name #>(*this);
<#
	}
#>
};
} // namespace WRPC
