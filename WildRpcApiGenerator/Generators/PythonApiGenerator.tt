<#@ template language="C#" inherits="BaseApiGenerator" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#
	string typeToRpcEnum(ReflectionMethod.Parameter param)
	{
		return "RpcType." + param.elementType + (param.isArray ? "Array" : "");
	}

	string typeToPython(ReflectionMethod.Parameter param)
	{
		return param.elementType switch
		{
			{ } when isEnum(param) => "_" + param.elementTypeName,
			ElementType.Invalid => "Any",
			ElementType.Boolean => "bool",
			ElementType.Integer => "int",
			ElementType.Float => "float",
			ElementType.String => "str",
			_ => param.elementType.ToString()
		};
	}

	static string cleanupName(string name)
	{
		return name.Replace("::", "_");
	}

	string cleanupParam(ReflectionMethod.Parameter param)
	{
		if (isEnum(param))
		{
			return $"{param.name}.value";
		}
		return param.name;
	}


	string joinInputCalls(ReflectionMethod method)
	{
		var joined = method.inputs.Select(cleanupParam).join(cleanupName);
		return method.inputs.Length switch
		{
			0 => "None",
			1 => $"({joined},)", // trailing comma for single-argument tuples
			_ => $"({joined})",
		};
	}

	string joinReturnTypes(ReflectionMethod method)
	{
		return method.outputs.Length switch
		{
			0 => "None",
			1 => method.outputs.join(typeToPython),
			_ => $"Tuple[{method.outputs.join(typeToPython)}]",
		};
	}
#>
# -*- coding: future_fstrings -*-
"""
RPC bindings for the Wild game.

THIS FILE WAS AUTOGENERATED.
"""
from __future__ import print_function, absolute_import
from builtins import super

from .rpc_api import RpcApi, RpcMethod
from .rpc_types import RpcType, Vector3, Position, Quat, Color
from typing import Tuple, Any


class RpcApiWild(RpcApi):
	def __init__(self, address=("127.0.0.1", 9387)):  # type: (Tuple[str, int]) -> None
		super().__init__(address)
<#
	// manager instances
	foreach (var @class in reflectionDb.classes)
	{
		var memberName = @class.name.Replace("Manager", "").ToLowerFirstLetter();
		memberName = memberName.Replace("rPC", "rpc");
#>
		self.<#= memberName #> = <#= @class.name #>(self)
<#
	}
#>


<#
	// manager classes
	foreach (var @class in reflectionDb.classes)
	{
#>
class <#= @class.name #>(object):
	def __init__(self, api):  # type: (RpcApi) -> None
<#
		// manager method signatures
		foreach (var method in @class.methods)
		{
#>
		self._<#= method.name #> = RpcMethod(api, "<#= @class.name #>", "<#= method.name #>", [<#= method.inputs.join(typeToRpcEnum) #>], [<#= method.outputs.join(typeToRpcEnum) #>], thread_safe=<#= method.threadSafe ? "True" : "False" #>)
<#
		}
#>

<#
		// manager method wrappers
		foreach (var method in @class.methods)
		{
			var inputNames = method.inputs.joinNames(cleanupName);
			if (inputNames != "") inputNames = ", " + inputNames;
			var inputCalls = joinInputCalls(method);
#>
	def <#= method.niceName() #>(self<#= inputNames #>):  # type: (<#= method.inputs.join(typeToPython) #>) -> <#= joinReturnTypes(method) #>
<#
			if (method.outputs.Length == 0)
			{
#>
		self._<#= method.name #>.invoke(params=<#= inputCalls #>, results=None, throw_on_error=True)
<#
			}
			else
			{
#>
		_results = self._<#= method.name #>.invoke(params=<#= inputCalls #>, results=[], throw_on_error=True)
<#
				// some parameters need custom converters
				for (int i = 0; i < method.outputs.Length; i++)
				{
					var output = method.outputs[i];
					if (!isEnum(output)) continue;
					// TODO: handle conversion of array elements
#>
		_results[<#= i #>] = _<#= output.elementTypeName #>(_results[<#= i #>])
<#
				}
#>
		return _results<#= method.outputs.Length == 1 ? "[0]" : "" #>
<#
			}
#>

<#
		}

		// expose get/set method pairs as Python properties
		var properties = @class.findProperties();
		foreach (var property in properties)
		{
			if (property.getter.outputs.Length > 1)
			{
#>
	<#= property.name #> = property(<#= property.getter.niceName() #>, lambda self, *args: self.<#= property.setter.niceName() #>(*args))  # type: <#= joinReturnTypes(property.getter) #>
<#
			}
			else
			{
#>
	<#= property.name #> = property(<#= property.getter.niceName() #>, <#= property.setter.niceName() #>)  # type: <#= joinReturnTypes(property.getter) #>
<#
			}
		}

		// add padding if necessary
		if (properties.Any())
			WriteLine("");
#>

<#
	}
#>
#
# Enums
# NOTE: some property have the same name as their enum type, which messes up autocomplete, so we use an _alias.
#
from enum import IntEnum

<#
	foreach (var @enum in reflectionDb.enums)
	{
#>
class <#= @enum.name #>(IntEnum):
<#
		foreach (var (value, name) in @enum.values.Zip(@enum.names))
		{
			if (name.EndsWith("_COUNT")) continue;
#>
	<#= name #> = <#= value #>
<#
		}
#>
_<#= @enum.name #> = <#= @enum.name #>


<#
	}
#>

api = RpcApiWild()
