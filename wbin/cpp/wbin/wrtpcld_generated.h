// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_WRTPCLD_WBIN_H_
#define FLATBUFFERS_GENERATED_WRTPCLD_WBIN_H_

#include "flatbuffers/flatbuffers.h"

#include "wbin_generated.h"

namespace WBIN {

struct CloudPoint;
struct CloudPointBuilder;
struct CloudPointT;

struct CloudPointsChunk;
struct CloudPointsChunkBuilder;
struct CloudPointsChunkT;

struct RuntimePointCloud;
struct RuntimePointCloudBuilder;
struct RuntimePointCloudT;

struct CloudPointT : public flatbuffers::NativeTable {
  typedef CloudPoint TableType;
  uint16_t nameIndex = 0;
  std::unique_ptr<WBIN::Matrix43> matrix{};
};

struct CloudPoint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CloudPointT NativeTableType;
  typedef CloudPointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAMEINDEX = 4,
    VT_MATRIX = 6
  };
  uint16_t nameIndex() const {
    return GetField<uint16_t>(VT_NAMEINDEX, 0);
  }
  bool mutate_nameIndex(uint16_t _nameIndex) {
    return SetField<uint16_t>(VT_NAMEINDEX, _nameIndex, 0);
  }
  const WBIN::Matrix43 *matrix() const {
    return GetStruct<const WBIN::Matrix43 *>(VT_MATRIX);
  }
  WBIN::Matrix43 *mutable_matrix() {
    return GetStruct<WBIN::Matrix43 *>(VT_MATRIX);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_NAMEINDEX) &&
           VerifyField<WBIN::Matrix43>(verifier, VT_MATRIX) &&
           verifier.EndTable();
  }
  CloudPointT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CloudPointT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CloudPoint> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CloudPointT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CloudPointBuilder {
  typedef CloudPoint Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_nameIndex(uint16_t nameIndex) {
    fbb_.AddElement<uint16_t>(CloudPoint::VT_NAMEINDEX, nameIndex, 0);
  }
  void add_matrix(const WBIN::Matrix43 *matrix) {
    fbb_.AddStruct(CloudPoint::VT_MATRIX, matrix);
  }
  explicit CloudPointBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CloudPoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CloudPoint>(end);
    return o;
  }
};

inline flatbuffers::Offset<CloudPoint> CreateCloudPoint(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t nameIndex = 0,
    const WBIN::Matrix43 *matrix = 0) {
  CloudPointBuilder builder_(_fbb);
  builder_.add_matrix(matrix);
  builder_.add_nameIndex(nameIndex);
  return builder_.Finish();
}

flatbuffers::Offset<CloudPoint> CreateCloudPoint(flatbuffers::FlatBufferBuilder &_fbb, const CloudPointT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CloudPointsChunkT : public flatbuffers::NativeTable {
  typedef CloudPointsChunk TableType;
  std::unique_ptr<WBIN::Int3> coords{};
  std::vector<std::unique_ptr<WBIN::CloudPointT>> points{};
};

struct CloudPointsChunk FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CloudPointsChunkT NativeTableType;
  typedef CloudPointsChunkBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COORDS = 4,
    VT_POINTS = 6
  };
  const WBIN::Int3 *coords() const {
    return GetStruct<const WBIN::Int3 *>(VT_COORDS);
  }
  WBIN::Int3 *mutable_coords() {
    return GetStruct<WBIN::Int3 *>(VT_COORDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<WBIN::CloudPoint>> *points() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<WBIN::CloudPoint>> *>(VT_POINTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<WBIN::CloudPoint>> *mutable_points() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<WBIN::CloudPoint>> *>(VT_POINTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<WBIN::Int3>(verifier, VT_COORDS) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.VerifyVectorOfTables(points()) &&
           verifier.EndTable();
  }
  CloudPointsChunkT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CloudPointsChunkT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CloudPointsChunk> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CloudPointsChunkT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CloudPointsChunkBuilder {
  typedef CloudPointsChunk Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_coords(const WBIN::Int3 *coords) {
    fbb_.AddStruct(CloudPointsChunk::VT_COORDS, coords);
  }
  void add_points(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<WBIN::CloudPoint>>> points) {
    fbb_.AddOffset(CloudPointsChunk::VT_POINTS, points);
  }
  explicit CloudPointsChunkBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CloudPointsChunk> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CloudPointsChunk>(end);
    return o;
  }
};

inline flatbuffers::Offset<CloudPointsChunk> CreateCloudPointsChunk(
    flatbuffers::FlatBufferBuilder &_fbb,
    const WBIN::Int3 *coords = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<WBIN::CloudPoint>>> points = 0) {
  CloudPointsChunkBuilder builder_(_fbb);
  builder_.add_points(points);
  builder_.add_coords(coords);
  return builder_.Finish();
}

inline flatbuffers::Offset<CloudPointsChunk> CreateCloudPointsChunkDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const WBIN::Int3 *coords = 0,
    const std::vector<flatbuffers::Offset<WBIN::CloudPoint>> *points = nullptr) {
  auto points__ = points ? _fbb.CreateVector<flatbuffers::Offset<WBIN::CloudPoint>>(*points) : 0;
  return WBIN::CreateCloudPointsChunk(
      _fbb,
      coords,
      points__);
}

flatbuffers::Offset<CloudPointsChunk> CreateCloudPointsChunk(flatbuffers::FlatBufferBuilder &_fbb, const CloudPointsChunkT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RuntimePointCloudT : public flatbuffers::NativeTable {
  typedef RuntimePointCloud TableType;
  float chunkSize = 0.0f;
  std::vector<std::string> names{};
  std::vector<std::unique_ptr<WBIN::CloudPointsChunkT>> chunks{};
};

struct RuntimePointCloud FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RuntimePointCloudT NativeTableType;
  typedef RuntimePointCloudBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHUNKSIZE = 4,
    VT_NAMES = 6,
    VT_CHUNKS = 8
  };
  float chunkSize() const {
    return GetField<float>(VT_CHUNKSIZE, 0.0f);
  }
  bool mutate_chunkSize(float _chunkSize) {
    return SetField<float>(VT_CHUNKSIZE, _chunkSize, 0.0f);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *names() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_NAMES);
  }
  flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mutable_names() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_NAMES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<WBIN::CloudPointsChunk>> *chunks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<WBIN::CloudPointsChunk>> *>(VT_CHUNKS);
  }
  flatbuffers::Vector<flatbuffers::Offset<WBIN::CloudPointsChunk>> *mutable_chunks() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<WBIN::CloudPointsChunk>> *>(VT_CHUNKS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_CHUNKSIZE) &&
           VerifyOffset(verifier, VT_NAMES) &&
           verifier.VerifyVector(names()) &&
           verifier.VerifyVectorOfStrings(names()) &&
           VerifyOffset(verifier, VT_CHUNKS) &&
           verifier.VerifyVector(chunks()) &&
           verifier.VerifyVectorOfTables(chunks()) &&
           verifier.EndTable();
  }
  RuntimePointCloudT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RuntimePointCloudT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RuntimePointCloud> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RuntimePointCloudT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RuntimePointCloudBuilder {
  typedef RuntimePointCloud Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chunkSize(float chunkSize) {
    fbb_.AddElement<float>(RuntimePointCloud::VT_CHUNKSIZE, chunkSize, 0.0f);
  }
  void add_names(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> names) {
    fbb_.AddOffset(RuntimePointCloud::VT_NAMES, names);
  }
  void add_chunks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<WBIN::CloudPointsChunk>>> chunks) {
    fbb_.AddOffset(RuntimePointCloud::VT_CHUNKS, chunks);
  }
  explicit RuntimePointCloudBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RuntimePointCloud> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RuntimePointCloud>(end);
    return o;
  }
};

inline flatbuffers::Offset<RuntimePointCloud> CreateRuntimePointCloud(
    flatbuffers::FlatBufferBuilder &_fbb,
    float chunkSize = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> names = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<WBIN::CloudPointsChunk>>> chunks = 0) {
  RuntimePointCloudBuilder builder_(_fbb);
  builder_.add_chunks(chunks);
  builder_.add_names(names);
  builder_.add_chunkSize(chunkSize);
  return builder_.Finish();
}

inline flatbuffers::Offset<RuntimePointCloud> CreateRuntimePointCloudDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float chunkSize = 0.0f,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *names = nullptr,
    const std::vector<flatbuffers::Offset<WBIN::CloudPointsChunk>> *chunks = nullptr) {
  auto names__ = names ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*names) : 0;
  auto chunks__ = chunks ? _fbb.CreateVector<flatbuffers::Offset<WBIN::CloudPointsChunk>>(*chunks) : 0;
  return WBIN::CreateRuntimePointCloud(
      _fbb,
      chunkSize,
      names__,
      chunks__);
}

flatbuffers::Offset<RuntimePointCloud> CreateRuntimePointCloud(flatbuffers::FlatBufferBuilder &_fbb, const RuntimePointCloudT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline CloudPointT *CloudPoint::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CloudPointT>(new CloudPointT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CloudPoint::UnPackTo(CloudPointT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = nameIndex(); _o->nameIndex = _e; }
  { auto _e = matrix(); if (_e) _o->matrix = std::unique_ptr<WBIN::Matrix43>(new WBIN::Matrix43(*_e)); }
}

inline flatbuffers::Offset<CloudPoint> CloudPoint::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CloudPointT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCloudPoint(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CloudPoint> CreateCloudPoint(flatbuffers::FlatBufferBuilder &_fbb, const CloudPointT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CloudPointT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _nameIndex = _o->nameIndex;
  auto _matrix = _o->matrix ? _o->matrix.get() : 0;
  return WBIN::CreateCloudPoint(
      _fbb,
      _nameIndex,
      _matrix);
}

inline CloudPointsChunkT *CloudPointsChunk::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CloudPointsChunkT>(new CloudPointsChunkT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CloudPointsChunk::UnPackTo(CloudPointsChunkT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = coords(); if (_e) _o->coords = std::unique_ptr<WBIN::Int3>(new WBIN::Int3(*_e)); }
  { auto _e = points(); if (_e) { _o->points.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->points[_i] = std::unique_ptr<WBIN::CloudPointT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<CloudPointsChunk> CloudPointsChunk::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CloudPointsChunkT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCloudPointsChunk(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CloudPointsChunk> CreateCloudPointsChunk(flatbuffers::FlatBufferBuilder &_fbb, const CloudPointsChunkT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CloudPointsChunkT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _coords = _o->coords ? _o->coords.get() : 0;
  auto _points = _o->points.size() ? _fbb.CreateVector<flatbuffers::Offset<WBIN::CloudPoint>> (_o->points.size(), [](size_t i, _VectorArgs *__va) { return CreateCloudPoint(*__va->__fbb, __va->__o->points[i].get(), __va->__rehasher); }, &_va ) : 0;
  return WBIN::CreateCloudPointsChunk(
      _fbb,
      _coords,
      _points);
}

inline RuntimePointCloudT *RuntimePointCloud::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RuntimePointCloudT>(new RuntimePointCloudT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RuntimePointCloud::UnPackTo(RuntimePointCloudT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = chunkSize(); _o->chunkSize = _e; }
  { auto _e = names(); if (_e) { _o->names.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->names[_i] = _e->Get(_i)->str(); } } }
  { auto _e = chunks(); if (_e) { _o->chunks.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->chunks[_i] = std::unique_ptr<WBIN::CloudPointsChunkT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<RuntimePointCloud> RuntimePointCloud::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RuntimePointCloudT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRuntimePointCloud(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RuntimePointCloud> CreateRuntimePointCloud(flatbuffers::FlatBufferBuilder &_fbb, const RuntimePointCloudT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RuntimePointCloudT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _chunkSize = _o->chunkSize;
  auto _names = _o->names.size() ? _fbb.CreateVectorOfStrings(_o->names) : 0;
  auto _chunks = _o->chunks.size() ? _fbb.CreateVector<flatbuffers::Offset<WBIN::CloudPointsChunk>> (_o->chunks.size(), [](size_t i, _VectorArgs *__va) { return CreateCloudPointsChunk(*__va->__fbb, __va->__o->chunks[i].get(), __va->__rehasher); }, &_va ) : 0;
  return WBIN::CreateRuntimePointCloud(
      _fbb,
      _chunkSize,
      _names,
      _chunks);
}

inline const WBIN::RuntimePointCloud *GetRuntimePointCloud(const void *buf) {
  return flatbuffers::GetRoot<WBIN::RuntimePointCloud>(buf);
}

inline const WBIN::RuntimePointCloud *GetSizePrefixedRuntimePointCloud(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<WBIN::RuntimePointCloud>(buf);
}

inline RuntimePointCloud *GetMutableRuntimePointCloud(void *buf) {
  return flatbuffers::GetMutableRoot<RuntimePointCloud>(buf);
}

inline bool VerifyRuntimePointCloudBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<WBIN::RuntimePointCloud>(nullptr);
}

inline bool VerifySizePrefixedRuntimePointCloudBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<WBIN::RuntimePointCloud>(nullptr);
}

inline void FinishRuntimePointCloudBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<WBIN::RuntimePointCloud> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRuntimePointCloudBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<WBIN::RuntimePointCloud> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<WBIN::RuntimePointCloudT> UnPackRuntimePointCloud(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<WBIN::RuntimePointCloudT>(GetRuntimePointCloud(buf)->UnPack(res));
}

inline std::unique_ptr<WBIN::RuntimePointCloudT> UnPackSizePrefixedRuntimePointCloud(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<WBIN::RuntimePointCloudT>(GetSizePrefixedRuntimePointCloud(buf)->UnPack(res));
}

}  // namespace WBIN

#endif  // FLATBUFFERS_GENERATED_WRTPCLD_WBIN_H_
