// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_WRTPCLD_WBIN_H_
#define FLATBUFFERS_GENERATED_WRTPCLD_WBIN_H_

#include "flatbuffers/flatbuffers.h"

#include "wbin_generated.h"

namespace WBIN {

struct CloudPoint;

struct CloudPointsChunk;
struct CloudPointsChunkBuilder;
struct CloudPointsChunkT;

struct RuntimePointCloud;
struct RuntimePointCloudBuilder;
struct RuntimePointCloudT;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) CloudPoint FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t nameIndex_;
  int16_t padding0__;
  WBIN::Matrix43 matrix_;

 public:
  CloudPoint()
      : nameIndex_(0),
        padding0__(0),
        matrix_() {
    (void)padding0__;
  }
  CloudPoint(uint16_t _nameIndex, const WBIN::Matrix43 &_matrix)
      : nameIndex_(flatbuffers::EndianScalar(_nameIndex)),
        padding0__(0),
        matrix_(_matrix) {
    (void)padding0__;
  }
  uint16_t nameIndex() const {
    return flatbuffers::EndianScalar(nameIndex_);
  }
  void mutate_nameIndex(uint16_t _nameIndex) {
    flatbuffers::WriteScalar(&nameIndex_, _nameIndex);
  }
  const WBIN::Matrix43 &matrix() const {
    return matrix_;
  }
  WBIN::Matrix43 &mutable_matrix() {
    return matrix_;
  }
};
FLATBUFFERS_STRUCT_END(CloudPoint, 52);

struct CloudPointsChunkT : public flatbuffers::NativeTable {
  typedef CloudPointsChunk TableType;
  std::unique_ptr<WBIN::Int3> coords{};
  std::vector<WBIN::CloudPoint> points{};
};

struct CloudPointsChunk FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CloudPointsChunkT NativeTableType;
  typedef CloudPointsChunkBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COORDS = 4,
    VT_POINTS = 6
  };
  const WBIN::Int3 *coords() const {
    return GetStruct<const WBIN::Int3 *>(VT_COORDS);
  }
  WBIN::Int3 *mutable_coords() {
    return GetStruct<WBIN::Int3 *>(VT_COORDS);
  }
  const flatbuffers::Vector<const WBIN::CloudPoint *> *points() const {
    return GetPointer<const flatbuffers::Vector<const WBIN::CloudPoint *> *>(VT_POINTS);
  }
  flatbuffers::Vector<const WBIN::CloudPoint *> *mutable_points() {
    return GetPointer<flatbuffers::Vector<const WBIN::CloudPoint *> *>(VT_POINTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<WBIN::Int3>(verifier, VT_COORDS) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.EndTable();
  }
  CloudPointsChunkT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CloudPointsChunkT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CloudPointsChunk> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CloudPointsChunkT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CloudPointsChunkBuilder {
  typedef CloudPointsChunk Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_coords(const WBIN::Int3 *coords) {
    fbb_.AddStruct(CloudPointsChunk::VT_COORDS, coords);
  }
  void add_points(flatbuffers::Offset<flatbuffers::Vector<const WBIN::CloudPoint *>> points) {
    fbb_.AddOffset(CloudPointsChunk::VT_POINTS, points);
  }
  explicit CloudPointsChunkBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CloudPointsChunk> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CloudPointsChunk>(end);
    return o;
  }
};

inline flatbuffers::Offset<CloudPointsChunk> CreateCloudPointsChunk(
    flatbuffers::FlatBufferBuilder &_fbb,
    const WBIN::Int3 *coords = 0,
    flatbuffers::Offset<flatbuffers::Vector<const WBIN::CloudPoint *>> points = 0) {
  CloudPointsChunkBuilder builder_(_fbb);
  builder_.add_points(points);
  builder_.add_coords(coords);
  return builder_.Finish();
}

inline flatbuffers::Offset<CloudPointsChunk> CreateCloudPointsChunkDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const WBIN::Int3 *coords = 0,
    const std::vector<WBIN::CloudPoint> *points = nullptr) {
  auto points__ = points ? _fbb.CreateVectorOfStructs<WBIN::CloudPoint>(*points) : 0;
  return WBIN::CreateCloudPointsChunk(
      _fbb,
      coords,
      points__);
}

flatbuffers::Offset<CloudPointsChunk> CreateCloudPointsChunk(flatbuffers::FlatBufferBuilder &_fbb, const CloudPointsChunkT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RuntimePointCloudT : public flatbuffers::NativeTable {
  typedef RuntimePointCloud TableType;
  float chunkSize = 0.0f;
  std::vector<std::string> names{};
  std::vector<std::unique_ptr<WBIN::CloudPointsChunkT>> chunks{};
};

struct RuntimePointCloud FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RuntimePointCloudT NativeTableType;
  typedef RuntimePointCloudBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHUNKSIZE = 4,
    VT_NAMES = 6,
    VT_CHUNKS = 8
  };
  float chunkSize() const {
    return GetField<float>(VT_CHUNKSIZE, 0.0f);
  }
  bool mutate_chunkSize(float _chunkSize) {
    return SetField<float>(VT_CHUNKSIZE, _chunkSize, 0.0f);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *names() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_NAMES);
  }
  flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mutable_names() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_NAMES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<WBIN::CloudPointsChunk>> *chunks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<WBIN::CloudPointsChunk>> *>(VT_CHUNKS);
  }
  flatbuffers::Vector<flatbuffers::Offset<WBIN::CloudPointsChunk>> *mutable_chunks() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<WBIN::CloudPointsChunk>> *>(VT_CHUNKS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_CHUNKSIZE) &&
           VerifyOffset(verifier, VT_NAMES) &&
           verifier.VerifyVector(names()) &&
           verifier.VerifyVectorOfStrings(names()) &&
           VerifyOffset(verifier, VT_CHUNKS) &&
           verifier.VerifyVector(chunks()) &&
           verifier.VerifyVectorOfTables(chunks()) &&
           verifier.EndTable();
  }
  RuntimePointCloudT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RuntimePointCloudT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RuntimePointCloud> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RuntimePointCloudT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RuntimePointCloudBuilder {
  typedef RuntimePointCloud Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chunkSize(float chunkSize) {
    fbb_.AddElement<float>(RuntimePointCloud::VT_CHUNKSIZE, chunkSize, 0.0f);
  }
  void add_names(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> names) {
    fbb_.AddOffset(RuntimePointCloud::VT_NAMES, names);
  }
  void add_chunks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<WBIN::CloudPointsChunk>>> chunks) {
    fbb_.AddOffset(RuntimePointCloud::VT_CHUNKS, chunks);
  }
  explicit RuntimePointCloudBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RuntimePointCloud> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RuntimePointCloud>(end);
    return o;
  }
};

inline flatbuffers::Offset<RuntimePointCloud> CreateRuntimePointCloud(
    flatbuffers::FlatBufferBuilder &_fbb,
    float chunkSize = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> names = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<WBIN::CloudPointsChunk>>> chunks = 0) {
  RuntimePointCloudBuilder builder_(_fbb);
  builder_.add_chunks(chunks);
  builder_.add_names(names);
  builder_.add_chunkSize(chunkSize);
  return builder_.Finish();
}

inline flatbuffers::Offset<RuntimePointCloud> CreateRuntimePointCloudDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float chunkSize = 0.0f,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *names = nullptr,
    const std::vector<flatbuffers::Offset<WBIN::CloudPointsChunk>> *chunks = nullptr) {
  auto names__ = names ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*names) : 0;
  auto chunks__ = chunks ? _fbb.CreateVector<flatbuffers::Offset<WBIN::CloudPointsChunk>>(*chunks) : 0;
  return WBIN::CreateRuntimePointCloud(
      _fbb,
      chunkSize,
      names__,
      chunks__);
}

flatbuffers::Offset<RuntimePointCloud> CreateRuntimePointCloud(flatbuffers::FlatBufferBuilder &_fbb, const RuntimePointCloudT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline CloudPointsChunkT *CloudPointsChunk::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CloudPointsChunkT>(new CloudPointsChunkT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CloudPointsChunk::UnPackTo(CloudPointsChunkT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = coords(); if (_e) _o->coords = std::unique_ptr<WBIN::Int3>(new WBIN::Int3(*_e)); }
  { auto _e = points(); if (_e) { _o->points.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->points[_i] = *_e->Get(_i); } } }
}

inline flatbuffers::Offset<CloudPointsChunk> CloudPointsChunk::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CloudPointsChunkT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCloudPointsChunk(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CloudPointsChunk> CreateCloudPointsChunk(flatbuffers::FlatBufferBuilder &_fbb, const CloudPointsChunkT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CloudPointsChunkT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _coords = _o->coords ? _o->coords.get() : 0;
  auto _points = _o->points.size() ? _fbb.CreateVectorOfStructs(_o->points) : 0;
  return WBIN::CreateCloudPointsChunk(
      _fbb,
      _coords,
      _points);
}

inline RuntimePointCloudT *RuntimePointCloud::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RuntimePointCloudT>(new RuntimePointCloudT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RuntimePointCloud::UnPackTo(RuntimePointCloudT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = chunkSize(); _o->chunkSize = _e; }
  { auto _e = names(); if (_e) { _o->names.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->names[_i] = _e->Get(_i)->str(); } } }
  { auto _e = chunks(); if (_e) { _o->chunks.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->chunks[_i] = std::unique_ptr<WBIN::CloudPointsChunkT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<RuntimePointCloud> RuntimePointCloud::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RuntimePointCloudT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRuntimePointCloud(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RuntimePointCloud> CreateRuntimePointCloud(flatbuffers::FlatBufferBuilder &_fbb, const RuntimePointCloudT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RuntimePointCloudT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _chunkSize = _o->chunkSize;
  auto _names = _o->names.size() ? _fbb.CreateVectorOfStrings(_o->names) : 0;
  auto _chunks = _o->chunks.size() ? _fbb.CreateVector<flatbuffers::Offset<WBIN::CloudPointsChunk>> (_o->chunks.size(), [](size_t i, _VectorArgs *__va) { return CreateCloudPointsChunk(*__va->__fbb, __va->__o->chunks[i].get(), __va->__rehasher); }, &_va ) : 0;
  return WBIN::CreateRuntimePointCloud(
      _fbb,
      _chunkSize,
      _names,
      _chunks);
}

inline const WBIN::RuntimePointCloud *GetRuntimePointCloud(const void *buf) {
  return flatbuffers::GetRoot<WBIN::RuntimePointCloud>(buf);
}

inline const WBIN::RuntimePointCloud *GetSizePrefixedRuntimePointCloud(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<WBIN::RuntimePointCloud>(buf);
}

inline RuntimePointCloud *GetMutableRuntimePointCloud(void *buf) {
  return flatbuffers::GetMutableRoot<RuntimePointCloud>(buf);
}

inline bool VerifyRuntimePointCloudBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<WBIN::RuntimePointCloud>(nullptr);
}

inline bool VerifySizePrefixedRuntimePointCloudBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<WBIN::RuntimePointCloud>(nullptr);
}

inline void FinishRuntimePointCloudBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<WBIN::RuntimePointCloud> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRuntimePointCloudBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<WBIN::RuntimePointCloud> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<WBIN::RuntimePointCloudT> UnPackRuntimePointCloud(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<WBIN::RuntimePointCloudT>(GetRuntimePointCloud(buf)->UnPack(res));
}

inline std::unique_ptr<WBIN::RuntimePointCloudT> UnPackSizePrefixedRuntimePointCloud(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<WBIN::RuntimePointCloudT>(GetSizePrefixedRuntimePointCloud(buf)->UnPack(res));
}

}  // namespace WBIN

#endif  // FLATBUFFERS_GENERATED_WRTPCLD_WBIN_H_
