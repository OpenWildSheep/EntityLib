// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_WSDF_WBIN_H_
#define FLATBUFFERS_GENERATED_WSDF_WBIN_H_

#include "flatbuffers/flatbuffers.h"

#include "wbin_generated.h"

namespace WBIN {

struct shortval;
struct shortvalBuilder;
struct shortvalT;

struct floatval;
struct floatvalBuilder;
struct floatvalT;

struct doubleval;
struct doublevalBuilder;
struct doublevalT;

struct SDF;
struct SDFBuilder;
struct SDFT;

enum SDFValues : uint8_t {
  SDFValues_NONE = 0,
  SDFValues_shortval = 1,
  SDFValues_floatval = 2,
  SDFValues_doubleval = 3,
  SDFValues_MIN = SDFValues_NONE,
  SDFValues_MAX = SDFValues_doubleval
};

inline const SDFValues (&EnumValuesSDFValues())[4] {
  static const SDFValues values[] = {
    SDFValues_NONE,
    SDFValues_shortval,
    SDFValues_floatval,
    SDFValues_doubleval
  };
  return values;
}

inline const char * const *EnumNamesSDFValues() {
  static const char * const names[5] = {
    "NONE",
    "shortval",
    "floatval",
    "doubleval",
    nullptr
  };
  return names;
}

inline const char *EnumNameSDFValues(SDFValues e) {
  if (flatbuffers::IsOutRange(e, SDFValues_NONE, SDFValues_doubleval)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSDFValues()[index];
}

template<typename T> struct SDFValuesTraits {
  static const SDFValues enum_value = SDFValues_NONE;
};

template<> struct SDFValuesTraits<WBIN::shortval> {
  static const SDFValues enum_value = SDFValues_shortval;
};

template<> struct SDFValuesTraits<WBIN::floatval> {
  static const SDFValues enum_value = SDFValues_floatval;
};

template<> struct SDFValuesTraits<WBIN::doubleval> {
  static const SDFValues enum_value = SDFValues_doubleval;
};

struct SDFValuesUnion {
  SDFValues type;
  void *value;

  SDFValuesUnion() : type(SDFValues_NONE), value(nullptr) {}
  SDFValuesUnion(SDFValuesUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(SDFValues_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  SDFValuesUnion(const SDFValuesUnion &);
  SDFValuesUnion &operator=(const SDFValuesUnion &u)
    { SDFValuesUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  SDFValuesUnion &operator=(SDFValuesUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~SDFValuesUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = SDFValuesTraits<typename RT::TableType>::enum_value;
    if (type != SDFValues_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, SDFValues type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  WBIN::shortvalT *Asshortval() {
    return type == SDFValues_shortval ?
      reinterpret_cast<WBIN::shortvalT *>(value) : nullptr;
  }
  const WBIN::shortvalT *Asshortval() const {
    return type == SDFValues_shortval ?
      reinterpret_cast<const WBIN::shortvalT *>(value) : nullptr;
  }
  WBIN::floatvalT *Asfloatval() {
    return type == SDFValues_floatval ?
      reinterpret_cast<WBIN::floatvalT *>(value) : nullptr;
  }
  const WBIN::floatvalT *Asfloatval() const {
    return type == SDFValues_floatval ?
      reinterpret_cast<const WBIN::floatvalT *>(value) : nullptr;
  }
  WBIN::doublevalT *Asdoubleval() {
    return type == SDFValues_doubleval ?
      reinterpret_cast<WBIN::doublevalT *>(value) : nullptr;
  }
  const WBIN::doublevalT *Asdoubleval() const {
    return type == SDFValues_doubleval ?
      reinterpret_cast<const WBIN::doublevalT *>(value) : nullptr;
  }
};

bool VerifySDFValues(flatbuffers::Verifier &verifier, const void *obj, SDFValues type);
bool VerifySDFValuesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct shortvalT : public flatbuffers::NativeTable {
  typedef shortval TableType;
  std::vector<int16_t> values{};
};

struct shortval FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef shortvalT NativeTableType;
  typedef shortvalBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const flatbuffers::Vector<int16_t> *values() const {
    return GetPointer<const flatbuffers::Vector<int16_t> *>(VT_VALUES);
  }
  flatbuffers::Vector<int16_t> *mutable_values() {
    return GetPointer<flatbuffers::Vector<int16_t> *>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.EndTable();
  }
  shortvalT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(shortvalT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<shortval> Pack(flatbuffers::FlatBufferBuilder &_fbb, const shortvalT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct shortvalBuilder {
  typedef shortval Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values(flatbuffers::Offset<flatbuffers::Vector<int16_t>> values) {
    fbb_.AddOffset(shortval::VT_VALUES, values);
  }
  explicit shortvalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<shortval> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<shortval>(end);
    fbb_.Required(o, shortval::VT_VALUES);
    return o;
  }
};

inline flatbuffers::Offset<shortval> Createshortval(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int16_t>> values = 0) {
  shortvalBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline flatbuffers::Offset<shortval> CreateshortvalDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int16_t> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<int16_t>(*values) : 0;
  return WBIN::Createshortval(
      _fbb,
      values__);
}

flatbuffers::Offset<shortval> Createshortval(flatbuffers::FlatBufferBuilder &_fbb, const shortvalT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct floatvalT : public flatbuffers::NativeTable {
  typedef floatval TableType;
  std::vector<float> values{};
};

struct floatval FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef floatvalT NativeTableType;
  typedef floatvalBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const flatbuffers::Vector<float> *values() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VALUES);
  }
  flatbuffers::Vector<float> *mutable_values() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.EndTable();
  }
  floatvalT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(floatvalT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<floatval> Pack(flatbuffers::FlatBufferBuilder &_fbb, const floatvalT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct floatvalBuilder {
  typedef floatval Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values(flatbuffers::Offset<flatbuffers::Vector<float>> values) {
    fbb_.AddOffset(floatval::VT_VALUES, values);
  }
  explicit floatvalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<floatval> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<floatval>(end);
    fbb_.Required(o, floatval::VT_VALUES);
    return o;
  }
};

inline flatbuffers::Offset<floatval> Createfloatval(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> values = 0) {
  floatvalBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline flatbuffers::Offset<floatval> CreatefloatvalDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<float>(*values) : 0;
  return WBIN::Createfloatval(
      _fbb,
      values__);
}

flatbuffers::Offset<floatval> Createfloatval(flatbuffers::FlatBufferBuilder &_fbb, const floatvalT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct doublevalT : public flatbuffers::NativeTable {
  typedef doubleval TableType;
  std::vector<double> values{};
};

struct doubleval FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef doublevalT NativeTableType;
  typedef doublevalBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const flatbuffers::Vector<double> *values() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_VALUES);
  }
  flatbuffers::Vector<double> *mutable_values() {
    return GetPointer<flatbuffers::Vector<double> *>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.EndTable();
  }
  doublevalT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(doublevalT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<doubleval> Pack(flatbuffers::FlatBufferBuilder &_fbb, const doublevalT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct doublevalBuilder {
  typedef doubleval Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values(flatbuffers::Offset<flatbuffers::Vector<double>> values) {
    fbb_.AddOffset(doubleval::VT_VALUES, values);
  }
  explicit doublevalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<doubleval> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<doubleval>(end);
    fbb_.Required(o, doubleval::VT_VALUES);
    return o;
  }
};

inline flatbuffers::Offset<doubleval> Createdoubleval(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> values = 0) {
  doublevalBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline flatbuffers::Offset<doubleval> CreatedoublevalDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<double>(*values) : 0;
  return WBIN::Createdoubleval(
      _fbb,
      values__);
}

flatbuffers::Offset<doubleval> Createdoubleval(flatbuffers::FlatBufferBuilder &_fbb, const doublevalT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SDFT : public flatbuffers::NativeTable {
  typedef SDF TableType;
  WBIN::SDFValuesUnion values{};
  std::unique_ptr<WBIN::UInt3> resolution{};
  std::unique_ptr<WBIN::Float3> originOffset{};
  float voxelSize = 1.0f;
};

struct SDF FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SDFT NativeTableType;
  typedef SDFBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES_TYPE = 4,
    VT_VALUES = 6,
    VT_RESOLUTION = 8,
    VT_ORIGINOFFSET = 10,
    VT_VOXELSIZE = 12
  };
  WBIN::SDFValues values_type() const {
    return static_cast<WBIN::SDFValues>(GetField<uint8_t>(VT_VALUES_TYPE, 0));
  }
  const void *values() const {
    return GetPointer<const void *>(VT_VALUES);
  }
  template<typename T> const T *values_as() const;
  const WBIN::shortval *values_as_shortval() const {
    return values_type() == WBIN::SDFValues_shortval ? static_cast<const WBIN::shortval *>(values()) : nullptr;
  }
  const WBIN::floatval *values_as_floatval() const {
    return values_type() == WBIN::SDFValues_floatval ? static_cast<const WBIN::floatval *>(values()) : nullptr;
  }
  const WBIN::doubleval *values_as_doubleval() const {
    return values_type() == WBIN::SDFValues_doubleval ? static_cast<const WBIN::doubleval *>(values()) : nullptr;
  }
  void *mutable_values() {
    return GetPointer<void *>(VT_VALUES);
  }
  const WBIN::UInt3 *resolution() const {
    return GetStruct<const WBIN::UInt3 *>(VT_RESOLUTION);
  }
  WBIN::UInt3 *mutable_resolution() {
    return GetStruct<WBIN::UInt3 *>(VT_RESOLUTION);
  }
  const WBIN::Float3 *originOffset() const {
    return GetStruct<const WBIN::Float3 *>(VT_ORIGINOFFSET);
  }
  WBIN::Float3 *mutable_originOffset() {
    return GetStruct<WBIN::Float3 *>(VT_ORIGINOFFSET);
  }
  float voxelSize() const {
    return GetField<float>(VT_VOXELSIZE, 1.0f);
  }
  bool mutate_voxelSize(float _voxelSize) {
    return SetField<float>(VT_VOXELSIZE, _voxelSize, 1.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUES_TYPE) &&
           VerifyOffsetRequired(verifier, VT_VALUES) &&
           VerifySDFValues(verifier, values(), values_type()) &&
           VerifyFieldRequired<WBIN::UInt3>(verifier, VT_RESOLUTION) &&
           VerifyFieldRequired<WBIN::Float3>(verifier, VT_ORIGINOFFSET) &&
           VerifyField<float>(verifier, VT_VOXELSIZE) &&
           verifier.EndTable();
  }
  SDFT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SDFT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SDF> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SDFT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const WBIN::shortval *SDF::values_as<WBIN::shortval>() const {
  return values_as_shortval();
}

template<> inline const WBIN::floatval *SDF::values_as<WBIN::floatval>() const {
  return values_as_floatval();
}

template<> inline const WBIN::doubleval *SDF::values_as<WBIN::doubleval>() const {
  return values_as_doubleval();
}

struct SDFBuilder {
  typedef SDF Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values_type(WBIN::SDFValues values_type) {
    fbb_.AddElement<uint8_t>(SDF::VT_VALUES_TYPE, static_cast<uint8_t>(values_type), 0);
  }
  void add_values(flatbuffers::Offset<void> values) {
    fbb_.AddOffset(SDF::VT_VALUES, values);
  }
  void add_resolution(const WBIN::UInt3 *resolution) {
    fbb_.AddStruct(SDF::VT_RESOLUTION, resolution);
  }
  void add_originOffset(const WBIN::Float3 *originOffset) {
    fbb_.AddStruct(SDF::VT_ORIGINOFFSET, originOffset);
  }
  void add_voxelSize(float voxelSize) {
    fbb_.AddElement<float>(SDF::VT_VOXELSIZE, voxelSize, 1.0f);
  }
  explicit SDFBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SDF> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SDF>(end);
    fbb_.Required(o, SDF::VT_VALUES);
    fbb_.Required(o, SDF::VT_RESOLUTION);
    fbb_.Required(o, SDF::VT_ORIGINOFFSET);
    return o;
  }
};

inline flatbuffers::Offset<SDF> CreateSDF(
    flatbuffers::FlatBufferBuilder &_fbb,
    WBIN::SDFValues values_type = WBIN::SDFValues_NONE,
    flatbuffers::Offset<void> values = 0,
    const WBIN::UInt3 *resolution = 0,
    const WBIN::Float3 *originOffset = 0,
    float voxelSize = 1.0f) {
  SDFBuilder builder_(_fbb);
  builder_.add_voxelSize(voxelSize);
  builder_.add_originOffset(originOffset);
  builder_.add_resolution(resolution);
  builder_.add_values(values);
  builder_.add_values_type(values_type);
  return builder_.Finish();
}

flatbuffers::Offset<SDF> CreateSDF(flatbuffers::FlatBufferBuilder &_fbb, const SDFT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline shortvalT *shortval::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<shortvalT>(new shortvalT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void shortval::UnPackTo(shortvalT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->values[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<shortval> shortval::Pack(flatbuffers::FlatBufferBuilder &_fbb, const shortvalT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Createshortval(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<shortval> Createshortval(flatbuffers::FlatBufferBuilder &_fbb, const shortvalT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const shortvalT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _values = _fbb.CreateVector(_o->values);
  return WBIN::Createshortval(
      _fbb,
      _values);
}

inline floatvalT *floatval::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<floatvalT>(new floatvalT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void floatval::UnPackTo(floatvalT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->values[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<floatval> floatval::Pack(flatbuffers::FlatBufferBuilder &_fbb, const floatvalT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Createfloatval(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<floatval> Createfloatval(flatbuffers::FlatBufferBuilder &_fbb, const floatvalT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const floatvalT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _values = _fbb.CreateVector(_o->values);
  return WBIN::Createfloatval(
      _fbb,
      _values);
}

inline doublevalT *doubleval::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<doublevalT>(new doublevalT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void doubleval::UnPackTo(doublevalT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->values[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<doubleval> doubleval::Pack(flatbuffers::FlatBufferBuilder &_fbb, const doublevalT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Createdoubleval(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<doubleval> Createdoubleval(flatbuffers::FlatBufferBuilder &_fbb, const doublevalT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const doublevalT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _values = _fbb.CreateVector(_o->values);
  return WBIN::Createdoubleval(
      _fbb,
      _values);
}

inline SDFT *SDF::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SDFT>(new SDFT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SDF::UnPackTo(SDFT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = values_type(); _o->values.type = _e; }
  { auto _e = values(); if (_e) _o->values.value = WBIN::SDFValuesUnion::UnPack(_e, values_type(), _resolver); }
  { auto _e = resolution(); if (_e) _o->resolution = std::unique_ptr<WBIN::UInt3>(new WBIN::UInt3(*_e)); }
  { auto _e = originOffset(); if (_e) _o->originOffset = std::unique_ptr<WBIN::Float3>(new WBIN::Float3(*_e)); }
  { auto _e = voxelSize(); _o->voxelSize = _e; }
}

inline flatbuffers::Offset<SDF> SDF::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SDFT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSDF(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SDF> CreateSDF(flatbuffers::FlatBufferBuilder &_fbb, const SDFT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SDFT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _values_type = _o->values.type;
  auto _values = _o->values.Pack(_fbb);
  auto _resolution = _o->resolution ? _o->resolution.get() : 0;
  auto _originOffset = _o->originOffset ? _o->originOffset.get() : 0;
  auto _voxelSize = _o->voxelSize;
  return WBIN::CreateSDF(
      _fbb,
      _values_type,
      _values,
      _resolution,
      _originOffset,
      _voxelSize);
}

inline bool VerifySDFValues(flatbuffers::Verifier &verifier, const void *obj, SDFValues type) {
  switch (type) {
    case SDFValues_NONE: {
      return true;
    }
    case SDFValues_shortval: {
      auto ptr = reinterpret_cast<const WBIN::shortval *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SDFValues_floatval: {
      auto ptr = reinterpret_cast<const WBIN::floatval *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SDFValues_doubleval: {
      auto ptr = reinterpret_cast<const WBIN::doubleval *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifySDFValuesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifySDFValues(
        verifier,  values->Get(i), types->GetEnum<SDFValues>(i))) {
      return false;
    }
  }
  return true;
}

inline void *SDFValuesUnion::UnPack(const void *obj, SDFValues type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case SDFValues_shortval: {
      auto ptr = reinterpret_cast<const WBIN::shortval *>(obj);
      return ptr->UnPack(resolver);
    }
    case SDFValues_floatval: {
      auto ptr = reinterpret_cast<const WBIN::floatval *>(obj);
      return ptr->UnPack(resolver);
    }
    case SDFValues_doubleval: {
      auto ptr = reinterpret_cast<const WBIN::doubleval *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> SDFValuesUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case SDFValues_shortval: {
      auto ptr = reinterpret_cast<const WBIN::shortvalT *>(value);
      return Createshortval(_fbb, ptr, _rehasher).Union();
    }
    case SDFValues_floatval: {
      auto ptr = reinterpret_cast<const WBIN::floatvalT *>(value);
      return Createfloatval(_fbb, ptr, _rehasher).Union();
    }
    case SDFValues_doubleval: {
      auto ptr = reinterpret_cast<const WBIN::doublevalT *>(value);
      return Createdoubleval(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline SDFValuesUnion::SDFValuesUnion(const SDFValuesUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case SDFValues_shortval: {
      value = new WBIN::shortvalT(*reinterpret_cast<WBIN::shortvalT *>(u.value));
      break;
    }
    case SDFValues_floatval: {
      value = new WBIN::floatvalT(*reinterpret_cast<WBIN::floatvalT *>(u.value));
      break;
    }
    case SDFValues_doubleval: {
      value = new WBIN::doublevalT(*reinterpret_cast<WBIN::doublevalT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void SDFValuesUnion::Reset() {
  switch (type) {
    case SDFValues_shortval: {
      auto ptr = reinterpret_cast<WBIN::shortvalT *>(value);
      delete ptr;
      break;
    }
    case SDFValues_floatval: {
      auto ptr = reinterpret_cast<WBIN::floatvalT *>(value);
      delete ptr;
      break;
    }
    case SDFValues_doubleval: {
      auto ptr = reinterpret_cast<WBIN::doublevalT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = SDFValues_NONE;
}

inline const WBIN::SDF *GetSDF(const void *buf) {
  return flatbuffers::GetRoot<WBIN::SDF>(buf);
}

inline const WBIN::SDF *GetSizePrefixedSDF(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<WBIN::SDF>(buf);
}

inline SDF *GetMutableSDF(void *buf) {
  return flatbuffers::GetMutableRoot<SDF>(buf);
}

inline bool VerifySDFBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<WBIN::SDF>(nullptr);
}

inline bool VerifySizePrefixedSDFBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<WBIN::SDF>(nullptr);
}

inline void FinishSDFBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<WBIN::SDF> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSDFBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<WBIN::SDF> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<WBIN::SDFT> UnPackSDF(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<WBIN::SDFT>(GetSDF(buf)->UnPack(res));
}

inline std::unique_ptr<WBIN::SDFT> UnPackSizePrefixedSDF(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<WBIN::SDFT>(GetSizePrefixedSDF(buf)->UnPack(res));
}

}  // namespace WBIN

#endif  // FLATBUFFERS_GENERATED_WSDF_WBIN_H_
