# automatically generated by the FlatBuffers compiler, do not modify

# namespace: MAX

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

class Animation(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Animation()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsAnimation(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Animation
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Animation
    def PositionX(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from MAX.Keyframe import Keyframe
            obj = Keyframe()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Animation
    def PositionXLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Animation
    def PositionXIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # Animation
    def PositionY(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from MAX.Keyframe import Keyframe
            obj = Keyframe()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Animation
    def PositionYLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Animation
    def PositionYIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # Animation
    def PositionZ(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from MAX.Keyframe import Keyframe
            obj = Keyframe()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Animation
    def PositionZLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Animation
    def PositionZIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # Animation
    def OrientationX(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from MAX.Keyframe import Keyframe
            obj = Keyframe()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Animation
    def OrientationXLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Animation
    def OrientationXIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # Animation
    def OrientationY(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from MAX.Keyframe import Keyframe
            obj = Keyframe()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Animation
    def OrientationYLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Animation
    def OrientationYIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

    # Animation
    def OrientationZ(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from MAX.Keyframe import Keyframe
            obj = Keyframe()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Animation
    def OrientationZLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Animation
    def OrientationZIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        return o == 0

    # Animation
    def Scale(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from MAX.Keyframe import Keyframe
            obj = Keyframe()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Animation
    def ScaleLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Animation
    def ScaleIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        return o == 0

def Start(builder): builder.StartObject(7)
def AnimationStart(builder):
    """This method is deprecated. Please switch to Start."""
    return Start(builder)
def AddPositionX(builder, positionX): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(positionX), 0)
def AnimationAddPositionX(builder, positionX):
    """This method is deprecated. Please switch to AddPositionX."""
    return AddPositionX(builder, positionX)
def StartPositionXVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def AnimationStartPositionXVector(builder, numElems):
    """This method is deprecated. Please switch to Start."""
    return StartPositionXVector(builder, numElems)
def AddPositionY(builder, positionY): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(positionY), 0)
def AnimationAddPositionY(builder, positionY):
    """This method is deprecated. Please switch to AddPositionY."""
    return AddPositionY(builder, positionY)
def StartPositionYVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def AnimationStartPositionYVector(builder, numElems):
    """This method is deprecated. Please switch to Start."""
    return StartPositionYVector(builder, numElems)
def AddPositionZ(builder, positionZ): builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(positionZ), 0)
def AnimationAddPositionZ(builder, positionZ):
    """This method is deprecated. Please switch to AddPositionZ."""
    return AddPositionZ(builder, positionZ)
def StartPositionZVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def AnimationStartPositionZVector(builder, numElems):
    """This method is deprecated. Please switch to Start."""
    return StartPositionZVector(builder, numElems)
def AddOrientationX(builder, orientationX): builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(orientationX), 0)
def AnimationAddOrientationX(builder, orientationX):
    """This method is deprecated. Please switch to AddOrientationX."""
    return AddOrientationX(builder, orientationX)
def StartOrientationXVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def AnimationStartOrientationXVector(builder, numElems):
    """This method is deprecated. Please switch to Start."""
    return StartOrientationXVector(builder, numElems)
def AddOrientationY(builder, orientationY): builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(orientationY), 0)
def AnimationAddOrientationY(builder, orientationY):
    """This method is deprecated. Please switch to AddOrientationY."""
    return AddOrientationY(builder, orientationY)
def StartOrientationYVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def AnimationStartOrientationYVector(builder, numElems):
    """This method is deprecated. Please switch to Start."""
    return StartOrientationYVector(builder, numElems)
def AddOrientationZ(builder, orientationZ): builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(orientationZ), 0)
def AnimationAddOrientationZ(builder, orientationZ):
    """This method is deprecated. Please switch to AddOrientationZ."""
    return AddOrientationZ(builder, orientationZ)
def StartOrientationZVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def AnimationStartOrientationZVector(builder, numElems):
    """This method is deprecated. Please switch to Start."""
    return StartOrientationZVector(builder, numElems)
def AddScale(builder, scale): builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(scale), 0)
def AnimationAddScale(builder, scale):
    """This method is deprecated. Please switch to AddScale."""
    return AddScale(builder, scale)
def StartScaleVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def AnimationStartScaleVector(builder, numElems):
    """This method is deprecated. Please switch to Start."""
    return StartScaleVector(builder, numElems)
def End(builder): return builder.EndObject()
def AnimationEnd(builder):
    """This method is deprecated. Please switch to End."""
    return End(builder)
import MAX.Keyframe
try:
    from typing import List
except:
    pass

class AnimationT(object):

    # AnimationT
    def __init__(self):
        self.positionX = None  # type: List[MAX.Keyframe.KeyframeT]
        self.positionY = None  # type: List[MAX.Keyframe.KeyframeT]
        self.positionZ = None  # type: List[MAX.Keyframe.KeyframeT]
        self.orientationX = None  # type: List[MAX.Keyframe.KeyframeT]
        self.orientationY = None  # type: List[MAX.Keyframe.KeyframeT]
        self.orientationZ = None  # type: List[MAX.Keyframe.KeyframeT]
        self.scale = None  # type: List[MAX.Keyframe.KeyframeT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        animation = Animation()
        animation.Init(buf, pos)
        return cls.InitFromObj(animation)

    @classmethod
    def InitFromObj(cls, animation):
        x = AnimationT()
        x._UnPack(animation)
        return x

    # AnimationT
    def _UnPack(self, animation):
        if animation is None:
            return
        if not animation.PositionXIsNone():
            self.positionX = []
            for i in range(animation.PositionXLength()):
                if animation.PositionX(i) is None:
                    self.positionX.append(None)
                else:
                    keyframe_ = MAX.Keyframe.KeyframeT.InitFromObj(animation.PositionX(i))
                    self.positionX.append(keyframe_)
        if not animation.PositionYIsNone():
            self.positionY = []
            for i in range(animation.PositionYLength()):
                if animation.PositionY(i) is None:
                    self.positionY.append(None)
                else:
                    keyframe_ = MAX.Keyframe.KeyframeT.InitFromObj(animation.PositionY(i))
                    self.positionY.append(keyframe_)
        if not animation.PositionZIsNone():
            self.positionZ = []
            for i in range(animation.PositionZLength()):
                if animation.PositionZ(i) is None:
                    self.positionZ.append(None)
                else:
                    keyframe_ = MAX.Keyframe.KeyframeT.InitFromObj(animation.PositionZ(i))
                    self.positionZ.append(keyframe_)
        if not animation.OrientationXIsNone():
            self.orientationX = []
            for i in range(animation.OrientationXLength()):
                if animation.OrientationX(i) is None:
                    self.orientationX.append(None)
                else:
                    keyframe_ = MAX.Keyframe.KeyframeT.InitFromObj(animation.OrientationX(i))
                    self.orientationX.append(keyframe_)
        if not animation.OrientationYIsNone():
            self.orientationY = []
            for i in range(animation.OrientationYLength()):
                if animation.OrientationY(i) is None:
                    self.orientationY.append(None)
                else:
                    keyframe_ = MAX.Keyframe.KeyframeT.InitFromObj(animation.OrientationY(i))
                    self.orientationY.append(keyframe_)
        if not animation.OrientationZIsNone():
            self.orientationZ = []
            for i in range(animation.OrientationZLength()):
                if animation.OrientationZ(i) is None:
                    self.orientationZ.append(None)
                else:
                    keyframe_ = MAX.Keyframe.KeyframeT.InitFromObj(animation.OrientationZ(i))
                    self.orientationZ.append(keyframe_)
        if not animation.ScaleIsNone():
            self.scale = []
            for i in range(animation.ScaleLength()):
                if animation.Scale(i) is None:
                    self.scale.append(None)
                else:
                    keyframe_ = MAX.Keyframe.KeyframeT.InitFromObj(animation.Scale(i))
                    self.scale.append(keyframe_)

    # AnimationT
    def Pack(self, builder):
        if self.positionX is not None:
            positionXlist = []
            for i in range(len(self.positionX)):
                positionXlist.append(self.positionX[i].Pack(builder))
            StartPositionXVector(builder, len(self.positionX))
            for i in reversed(range(len(self.positionX))):
                builder.PrependUOffsetTRelative(positionXlist[i])
            positionX = builder.EndVector()
        if self.positionY is not None:
            positionYlist = []
            for i in range(len(self.positionY)):
                positionYlist.append(self.positionY[i].Pack(builder))
            StartPositionYVector(builder, len(self.positionY))
            for i in reversed(range(len(self.positionY))):
                builder.PrependUOffsetTRelative(positionYlist[i])
            positionY = builder.EndVector()
        if self.positionZ is not None:
            positionZlist = []
            for i in range(len(self.positionZ)):
                positionZlist.append(self.positionZ[i].Pack(builder))
            StartPositionZVector(builder, len(self.positionZ))
            for i in reversed(range(len(self.positionZ))):
                builder.PrependUOffsetTRelative(positionZlist[i])
            positionZ = builder.EndVector()
        if self.orientationX is not None:
            orientationXlist = []
            for i in range(len(self.orientationX)):
                orientationXlist.append(self.orientationX[i].Pack(builder))
            StartOrientationXVector(builder, len(self.orientationX))
            for i in reversed(range(len(self.orientationX))):
                builder.PrependUOffsetTRelative(orientationXlist[i])
            orientationX = builder.EndVector()
        if self.orientationY is not None:
            orientationYlist = []
            for i in range(len(self.orientationY)):
                orientationYlist.append(self.orientationY[i].Pack(builder))
            StartOrientationYVector(builder, len(self.orientationY))
            for i in reversed(range(len(self.orientationY))):
                builder.PrependUOffsetTRelative(orientationYlist[i])
            orientationY = builder.EndVector()
        if self.orientationZ is not None:
            orientationZlist = []
            for i in range(len(self.orientationZ)):
                orientationZlist.append(self.orientationZ[i].Pack(builder))
            StartOrientationZVector(builder, len(self.orientationZ))
            for i in reversed(range(len(self.orientationZ))):
                builder.PrependUOffsetTRelative(orientationZlist[i])
            orientationZ = builder.EndVector()
        if self.scale is not None:
            scalelist = []
            for i in range(len(self.scale)):
                scalelist.append(self.scale[i].Pack(builder))
            StartScaleVector(builder, len(self.scale))
            for i in reversed(range(len(self.scale))):
                builder.PrependUOffsetTRelative(scalelist[i])
            scale = builder.EndVector()
        Start(builder)
        if self.positionX is not None:
            AddPositionX(builder, positionX)
        if self.positionY is not None:
            AddPositionY(builder, positionY)
        if self.positionZ is not None:
            AddPositionZ(builder, positionZ)
        if self.orientationX is not None:
            AddOrientationX(builder, orientationX)
        if self.orientationY is not None:
            AddOrientationY(builder, orientationY)
        if self.orientationZ is not None:
            AddOrientationZ(builder, orientationZ)
        if self.scale is not None:
            AddScale(builder, scale)
        animation = End(builder)
        return animation
