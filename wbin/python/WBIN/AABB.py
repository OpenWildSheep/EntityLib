# automatically generated by the FlatBuffers compiler, do not modify

# namespace: WBIN

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

class AABB(object):
    __slots__ = ['_tab']

    # AABB
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # AABB
    def Min(self, obj):
        obj.Init(self._tab.Bytes, self._tab.Pos + 0)
        return obj

    # AABB
    def Max(self, obj):
        obj.Init(self._tab.Bytes, self._tab.Pos + 12)
        return obj


def CreateAABB(builder, min_x, min_y, min_z, max_x, max_y, max_z):
    builder.Prep(4, 24)
    builder.Prep(4, 12)
    builder.PrependFloat32(max_z)
    builder.PrependFloat32(max_y)
    builder.PrependFloat32(max_x)
    builder.Prep(4, 12)
    builder.PrependFloat32(min_z)
    builder.PrependFloat32(min_y)
    builder.PrependFloat32(min_x)
    return builder.Offset()

import WBIN.Float3
try:
    from typing import Optional
except:
    pass

class AABBT(object):

    # AABBT
    def __init__(self):
        self.min = None  # type: Optional[WBIN.Float3.Float3T]
        self.max = None  # type: Optional[WBIN.Float3.Float3T]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        aABB = AABB()
        aABB.Init(buf, pos)
        return cls.InitFromObj(aABB)

    @classmethod
    def InitFromObj(cls, aABB):
        x = AABBT()
        x._UnPack(aABB)
        return x

    # AABBT
    def _UnPack(self, aABB):
        if aABB is None:
            return
        if aABB.Min(WBIN.Float3.Float3()) is not None:
            self.min = WBIN.Float3.Float3T.InitFromObj(aABB.Min(WBIN.Float3.Float3()))
        if aABB.Max(WBIN.Float3.Float3()) is not None:
            self.max = WBIN.Float3.Float3T.InitFromObj(aABB.Max(WBIN.Float3.Float3()))

    # AABBT
    def Pack(self, builder):
        return CreateAABB(builder, self.min.x, self.min.y, self.min.z, self.max.x, self.max.y, self.max.z)
