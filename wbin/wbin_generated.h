// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_WBIN_WBIN_H_
#define FLATBUFFERS_GENERATED_WBIN_WBIN_H_

#include "flatbuffers/flatbuffers.h"

namespace WBIN {

struct UInt3;

struct Float3;

struct Float2;

struct Float4;

struct Bool3;

struct Matrix44;

struct AABB;

struct FloatMask;
struct FloatMaskBuilder;
struct FloatMaskT;

struct Float2Channel;
struct Float2ChannelBuilder;
struct Float2ChannelT;

struct Float3Channel;
struct Float3ChannelBuilder;
struct Float3ChannelT;

struct Float4Channel;
struct Float4ChannelBuilder;
struct Float4ChannelT;

struct BoneWeight;

struct VertexBoneWeight;
struct VertexBoneWeightBuilder;
struct VertexBoneWeightT;

struct BoneMatrix;

struct Skin;
struct SkinBuilder;
struct SkinT;

struct SourceFileInf;
struct SourceFileInfBuilder;
struct SourceFileInfT;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) UInt3 FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t x_;
  uint32_t y_;
  uint32_t z_;

 public:
  UInt3() {
    memset(static_cast<void *>(this), 0, sizeof(UInt3));
  }
  UInt3(uint32_t _x, uint32_t _y, uint32_t _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  uint32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(uint32_t _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  uint32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
  void mutate_y(uint32_t _y) {
    flatbuffers::WriteScalar(&y_, _y);
  }
  uint32_t z() const {
    return flatbuffers::EndianScalar(z_);
  }
  void mutate_z(uint32_t _z) {
    flatbuffers::WriteScalar(&z_, _z);
  }
};
FLATBUFFERS_STRUCT_END(UInt3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Float3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Float3() {
    memset(static_cast<void *>(this), 0, sizeof(Float3));
  }
  Float3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    flatbuffers::WriteScalar(&y_, _y);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  void mutate_z(float _z) {
    flatbuffers::WriteScalar(&z_, _z);
  }
};
FLATBUFFERS_STRUCT_END(Float3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Float2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Float2() {
    memset(static_cast<void *>(this), 0, sizeof(Float2));
  }
  Float2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    flatbuffers::WriteScalar(&y_, _y);
  }
};
FLATBUFFERS_STRUCT_END(Float2, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Float4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Float4() {
    memset(static_cast<void *>(this), 0, sizeof(Float4));
  }
  Float4(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    flatbuffers::WriteScalar(&y_, _y);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  void mutate_z(float _z) {
    flatbuffers::WriteScalar(&z_, _z);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
  void mutate_w(float _w) {
    flatbuffers::WriteScalar(&w_, _w);
  }
};
FLATBUFFERS_STRUCT_END(Float4, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Bool3 FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t x_;
  uint8_t y_;
  uint8_t z_;

 public:
  Bool3() {
    memset(static_cast<void *>(this), 0, sizeof(Bool3));
  }
  Bool3(bool _x, bool _y, bool _z)
      : x_(flatbuffers::EndianScalar(static_cast<uint8_t>(_x))),
        y_(flatbuffers::EndianScalar(static_cast<uint8_t>(_y))),
        z_(flatbuffers::EndianScalar(static_cast<uint8_t>(_z))) {
  }
  bool x() const {
    return flatbuffers::EndianScalar(x_) != 0;
  }
  void mutate_x(bool _x) {
    flatbuffers::WriteScalar(&x_, static_cast<uint8_t>(_x));
  }
  bool y() const {
    return flatbuffers::EndianScalar(y_) != 0;
  }
  void mutate_y(bool _y) {
    flatbuffers::WriteScalar(&y_, static_cast<uint8_t>(_y));
  }
  bool z() const {
    return flatbuffers::EndianScalar(z_) != 0;
  }
  void mutate_z(bool _z) {
    flatbuffers::WriteScalar(&z_, static_cast<uint8_t>(_z));
  }
};
FLATBUFFERS_STRUCT_END(Bool3, 3);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Matrix44 FLATBUFFERS_FINAL_CLASS {
 private:
  float values_[16];

 public:
  Matrix44() {
    memset(static_cast<void *>(this), 0, sizeof(Matrix44));
  }
  const flatbuffers::Array<float, 16> *values() const {
    return reinterpret_cast<const flatbuffers::Array<float, 16> *>(values_);
  }
  flatbuffers::Array<float, 16> *mutable_values() {
    return reinterpret_cast<flatbuffers::Array<float, 16> *>(values_);
  }
};
FLATBUFFERS_STRUCT_END(Matrix44, 64);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) AABB FLATBUFFERS_FINAL_CLASS {
 private:
  WBIN::Float3 min_;
  WBIN::Float3 max_;

 public:
  AABB() {
    memset(static_cast<void *>(this), 0, sizeof(AABB));
  }
  AABB(const WBIN::Float3 &_min, const WBIN::Float3 &_max)
      : min_(_min),
        max_(_max) {
  }
  const WBIN::Float3 &min() const {
    return min_;
  }
  WBIN::Float3 &mutable_min() {
    return min_;
  }
  const WBIN::Float3 &max() const {
    return max_;
  }
  WBIN::Float3 &mutable_max() {
    return max_;
  }
};
FLATBUFFERS_STRUCT_END(AABB, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) BoneWeight FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t boneIndex_;
  float weight_;

 public:
  BoneWeight() {
    memset(static_cast<void *>(this), 0, sizeof(BoneWeight));
  }
  BoneWeight(uint32_t _boneIndex, float _weight)
      : boneIndex_(flatbuffers::EndianScalar(_boneIndex)),
        weight_(flatbuffers::EndianScalar(_weight)) {
  }
  uint32_t boneIndex() const {
    return flatbuffers::EndianScalar(boneIndex_);
  }
  void mutate_boneIndex(uint32_t _boneIndex) {
    flatbuffers::WriteScalar(&boneIndex_, _boneIndex);
  }
  float weight() const {
    return flatbuffers::EndianScalar(weight_);
  }
  void mutate_weight(float _weight) {
    flatbuffers::WriteScalar(&weight_, _weight);
  }
};
FLATBUFFERS_STRUCT_END(BoneWeight, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) BoneMatrix FLATBUFFERS_FINAL_CLASS {
 private:
  float matrix4_[16];

 public:
  BoneMatrix() {
    memset(static_cast<void *>(this), 0, sizeof(BoneMatrix));
  }
  const flatbuffers::Array<float, 16> *matrix4() const {
    return reinterpret_cast<const flatbuffers::Array<float, 16> *>(matrix4_);
  }
  flatbuffers::Array<float, 16> *mutable_matrix4() {
    return reinterpret_cast<flatbuffers::Array<float, 16> *>(matrix4_);
  }
};
FLATBUFFERS_STRUCT_END(BoneMatrix, 64);

struct FloatMaskT : public flatbuffers::NativeTable {
  typedef FloatMask TableType;
  std::vector<WBIN::UInt3> triangles;
  std::vector<float> vertexData;
  FloatMaskT() {
  }
};

struct FloatMask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FloatMaskT NativeTableType;
  typedef FloatMaskBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRIANGLES = 4,
    VT_VERTEXDATA = 6
  };
  const flatbuffers::Vector<const WBIN::UInt3 *> *triangles() const {
    return GetPointer<const flatbuffers::Vector<const WBIN::UInt3 *> *>(VT_TRIANGLES);
  }
  flatbuffers::Vector<const WBIN::UInt3 *> *mutable_triangles() {
    return GetPointer<flatbuffers::Vector<const WBIN::UInt3 *> *>(VT_TRIANGLES);
  }
  const flatbuffers::Vector<float> *vertexData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VERTEXDATA);
  }
  flatbuffers::Vector<float> *mutable_vertexData() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_VERTEXDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TRIANGLES) &&
           verifier.VerifyVector(triangles()) &&
           VerifyOffsetRequired(verifier, VT_VERTEXDATA) &&
           verifier.VerifyVector(vertexData()) &&
           verifier.EndTable();
  }
  FloatMaskT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FloatMaskT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FloatMask> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloatMaskT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FloatMaskBuilder {
  typedef FloatMask Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_triangles(flatbuffers::Offset<flatbuffers::Vector<const WBIN::UInt3 *>> triangles) {
    fbb_.AddOffset(FloatMask::VT_TRIANGLES, triangles);
  }
  void add_vertexData(flatbuffers::Offset<flatbuffers::Vector<float>> vertexData) {
    fbb_.AddOffset(FloatMask::VT_VERTEXDATA, vertexData);
  }
  explicit FloatMaskBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FloatMaskBuilder &operator=(const FloatMaskBuilder &);
  flatbuffers::Offset<FloatMask> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloatMask>(end);
    fbb_.Required(o, FloatMask::VT_TRIANGLES);
    fbb_.Required(o, FloatMask::VT_VERTEXDATA);
    return o;
  }
};

inline flatbuffers::Offset<FloatMask> CreateFloatMask(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const WBIN::UInt3 *>> triangles = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> vertexData = 0) {
  FloatMaskBuilder builder_(_fbb);
  builder_.add_vertexData(vertexData);
  builder_.add_triangles(triangles);
  return builder_.Finish();
}

inline flatbuffers::Offset<FloatMask> CreateFloatMaskDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<WBIN::UInt3> *triangles = nullptr,
    const std::vector<float> *vertexData = nullptr) {
  auto triangles__ = triangles ? _fbb.CreateVectorOfStructs<WBIN::UInt3>(*triangles) : 0;
  auto vertexData__ = vertexData ? _fbb.CreateVector<float>(*vertexData) : 0;
  return WBIN::CreateFloatMask(
      _fbb,
      triangles__,
      vertexData__);
}

flatbuffers::Offset<FloatMask> CreateFloatMask(flatbuffers::FlatBufferBuilder &_fbb, const FloatMaskT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Float2ChannelT : public flatbuffers::NativeTable {
  typedef Float2Channel TableType;
  std::vector<WBIN::UInt3> triangles;
  std::vector<WBIN::Float2> vertexData;
  Float2ChannelT() {
  }
};

struct Float2Channel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Float2ChannelT NativeTableType;
  typedef Float2ChannelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRIANGLES = 4,
    VT_VERTEXDATA = 6
  };
  const flatbuffers::Vector<const WBIN::UInt3 *> *triangles() const {
    return GetPointer<const flatbuffers::Vector<const WBIN::UInt3 *> *>(VT_TRIANGLES);
  }
  flatbuffers::Vector<const WBIN::UInt3 *> *mutable_triangles() {
    return GetPointer<flatbuffers::Vector<const WBIN::UInt3 *> *>(VT_TRIANGLES);
  }
  const flatbuffers::Vector<const WBIN::Float2 *> *vertexData() const {
    return GetPointer<const flatbuffers::Vector<const WBIN::Float2 *> *>(VT_VERTEXDATA);
  }
  flatbuffers::Vector<const WBIN::Float2 *> *mutable_vertexData() {
    return GetPointer<flatbuffers::Vector<const WBIN::Float2 *> *>(VT_VERTEXDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TRIANGLES) &&
           verifier.VerifyVector(triangles()) &&
           VerifyOffsetRequired(verifier, VT_VERTEXDATA) &&
           verifier.VerifyVector(vertexData()) &&
           verifier.EndTable();
  }
  Float2ChannelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Float2ChannelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Float2Channel> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Float2ChannelT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Float2ChannelBuilder {
  typedef Float2Channel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_triangles(flatbuffers::Offset<flatbuffers::Vector<const WBIN::UInt3 *>> triangles) {
    fbb_.AddOffset(Float2Channel::VT_TRIANGLES, triangles);
  }
  void add_vertexData(flatbuffers::Offset<flatbuffers::Vector<const WBIN::Float2 *>> vertexData) {
    fbb_.AddOffset(Float2Channel::VT_VERTEXDATA, vertexData);
  }
  explicit Float2ChannelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Float2ChannelBuilder &operator=(const Float2ChannelBuilder &);
  flatbuffers::Offset<Float2Channel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Float2Channel>(end);
    fbb_.Required(o, Float2Channel::VT_TRIANGLES);
    fbb_.Required(o, Float2Channel::VT_VERTEXDATA);
    return o;
  }
};

inline flatbuffers::Offset<Float2Channel> CreateFloat2Channel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const WBIN::UInt3 *>> triangles = 0,
    flatbuffers::Offset<flatbuffers::Vector<const WBIN::Float2 *>> vertexData = 0) {
  Float2ChannelBuilder builder_(_fbb);
  builder_.add_vertexData(vertexData);
  builder_.add_triangles(triangles);
  return builder_.Finish();
}

inline flatbuffers::Offset<Float2Channel> CreateFloat2ChannelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<WBIN::UInt3> *triangles = nullptr,
    const std::vector<WBIN::Float2> *vertexData = nullptr) {
  auto triangles__ = triangles ? _fbb.CreateVectorOfStructs<WBIN::UInt3>(*triangles) : 0;
  auto vertexData__ = vertexData ? _fbb.CreateVectorOfStructs<WBIN::Float2>(*vertexData) : 0;
  return WBIN::CreateFloat2Channel(
      _fbb,
      triangles__,
      vertexData__);
}

flatbuffers::Offset<Float2Channel> CreateFloat2Channel(flatbuffers::FlatBufferBuilder &_fbb, const Float2ChannelT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Float3ChannelT : public flatbuffers::NativeTable {
  typedef Float3Channel TableType;
  std::vector<WBIN::UInt3> triangles;
  std::vector<WBIN::Float3> vertexData;
  Float3ChannelT() {
  }
};

struct Float3Channel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Float3ChannelT NativeTableType;
  typedef Float3ChannelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRIANGLES = 4,
    VT_VERTEXDATA = 6
  };
  const flatbuffers::Vector<const WBIN::UInt3 *> *triangles() const {
    return GetPointer<const flatbuffers::Vector<const WBIN::UInt3 *> *>(VT_TRIANGLES);
  }
  flatbuffers::Vector<const WBIN::UInt3 *> *mutable_triangles() {
    return GetPointer<flatbuffers::Vector<const WBIN::UInt3 *> *>(VT_TRIANGLES);
  }
  const flatbuffers::Vector<const WBIN::Float3 *> *vertexData() const {
    return GetPointer<const flatbuffers::Vector<const WBIN::Float3 *> *>(VT_VERTEXDATA);
  }
  flatbuffers::Vector<const WBIN::Float3 *> *mutable_vertexData() {
    return GetPointer<flatbuffers::Vector<const WBIN::Float3 *> *>(VT_VERTEXDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TRIANGLES) &&
           verifier.VerifyVector(triangles()) &&
           VerifyOffsetRequired(verifier, VT_VERTEXDATA) &&
           verifier.VerifyVector(vertexData()) &&
           verifier.EndTable();
  }
  Float3ChannelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Float3ChannelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Float3Channel> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Float3ChannelT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Float3ChannelBuilder {
  typedef Float3Channel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_triangles(flatbuffers::Offset<flatbuffers::Vector<const WBIN::UInt3 *>> triangles) {
    fbb_.AddOffset(Float3Channel::VT_TRIANGLES, triangles);
  }
  void add_vertexData(flatbuffers::Offset<flatbuffers::Vector<const WBIN::Float3 *>> vertexData) {
    fbb_.AddOffset(Float3Channel::VT_VERTEXDATA, vertexData);
  }
  explicit Float3ChannelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Float3ChannelBuilder &operator=(const Float3ChannelBuilder &);
  flatbuffers::Offset<Float3Channel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Float3Channel>(end);
    fbb_.Required(o, Float3Channel::VT_TRIANGLES);
    fbb_.Required(o, Float3Channel::VT_VERTEXDATA);
    return o;
  }
};

inline flatbuffers::Offset<Float3Channel> CreateFloat3Channel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const WBIN::UInt3 *>> triangles = 0,
    flatbuffers::Offset<flatbuffers::Vector<const WBIN::Float3 *>> vertexData = 0) {
  Float3ChannelBuilder builder_(_fbb);
  builder_.add_vertexData(vertexData);
  builder_.add_triangles(triangles);
  return builder_.Finish();
}

inline flatbuffers::Offset<Float3Channel> CreateFloat3ChannelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<WBIN::UInt3> *triangles = nullptr,
    const std::vector<WBIN::Float3> *vertexData = nullptr) {
  auto triangles__ = triangles ? _fbb.CreateVectorOfStructs<WBIN::UInt3>(*triangles) : 0;
  auto vertexData__ = vertexData ? _fbb.CreateVectorOfStructs<WBIN::Float3>(*vertexData) : 0;
  return WBIN::CreateFloat3Channel(
      _fbb,
      triangles__,
      vertexData__);
}

flatbuffers::Offset<Float3Channel> CreateFloat3Channel(flatbuffers::FlatBufferBuilder &_fbb, const Float3ChannelT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Float4ChannelT : public flatbuffers::NativeTable {
  typedef Float4Channel TableType;
  std::vector<WBIN::UInt3> triangles;
  std::vector<WBIN::Float4> vertexData;
  Float4ChannelT() {
  }
};

struct Float4Channel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Float4ChannelT NativeTableType;
  typedef Float4ChannelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRIANGLES = 4,
    VT_VERTEXDATA = 6
  };
  const flatbuffers::Vector<const WBIN::UInt3 *> *triangles() const {
    return GetPointer<const flatbuffers::Vector<const WBIN::UInt3 *> *>(VT_TRIANGLES);
  }
  flatbuffers::Vector<const WBIN::UInt3 *> *mutable_triangles() {
    return GetPointer<flatbuffers::Vector<const WBIN::UInt3 *> *>(VT_TRIANGLES);
  }
  const flatbuffers::Vector<const WBIN::Float4 *> *vertexData() const {
    return GetPointer<const flatbuffers::Vector<const WBIN::Float4 *> *>(VT_VERTEXDATA);
  }
  flatbuffers::Vector<const WBIN::Float4 *> *mutable_vertexData() {
    return GetPointer<flatbuffers::Vector<const WBIN::Float4 *> *>(VT_VERTEXDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TRIANGLES) &&
           verifier.VerifyVector(triangles()) &&
           VerifyOffsetRequired(verifier, VT_VERTEXDATA) &&
           verifier.VerifyVector(vertexData()) &&
           verifier.EndTable();
  }
  Float4ChannelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Float4ChannelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Float4Channel> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Float4ChannelT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Float4ChannelBuilder {
  typedef Float4Channel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_triangles(flatbuffers::Offset<flatbuffers::Vector<const WBIN::UInt3 *>> triangles) {
    fbb_.AddOffset(Float4Channel::VT_TRIANGLES, triangles);
  }
  void add_vertexData(flatbuffers::Offset<flatbuffers::Vector<const WBIN::Float4 *>> vertexData) {
    fbb_.AddOffset(Float4Channel::VT_VERTEXDATA, vertexData);
  }
  explicit Float4ChannelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Float4ChannelBuilder &operator=(const Float4ChannelBuilder &);
  flatbuffers::Offset<Float4Channel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Float4Channel>(end);
    fbb_.Required(o, Float4Channel::VT_TRIANGLES);
    fbb_.Required(o, Float4Channel::VT_VERTEXDATA);
    return o;
  }
};

inline flatbuffers::Offset<Float4Channel> CreateFloat4Channel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const WBIN::UInt3 *>> triangles = 0,
    flatbuffers::Offset<flatbuffers::Vector<const WBIN::Float4 *>> vertexData = 0) {
  Float4ChannelBuilder builder_(_fbb);
  builder_.add_vertexData(vertexData);
  builder_.add_triangles(triangles);
  return builder_.Finish();
}

inline flatbuffers::Offset<Float4Channel> CreateFloat4ChannelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<WBIN::UInt3> *triangles = nullptr,
    const std::vector<WBIN::Float4> *vertexData = nullptr) {
  auto triangles__ = triangles ? _fbb.CreateVectorOfStructs<WBIN::UInt3>(*triangles) : 0;
  auto vertexData__ = vertexData ? _fbb.CreateVectorOfStructs<WBIN::Float4>(*vertexData) : 0;
  return WBIN::CreateFloat4Channel(
      _fbb,
      triangles__,
      vertexData__);
}

flatbuffers::Offset<Float4Channel> CreateFloat4Channel(flatbuffers::FlatBufferBuilder &_fbb, const Float4ChannelT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct VertexBoneWeightT : public flatbuffers::NativeTable {
  typedef VertexBoneWeight TableType;
  std::vector<WBIN::BoneWeight> boneWeight;
  VertexBoneWeightT() {
  }
};

struct VertexBoneWeight FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VertexBoneWeightT NativeTableType;
  typedef VertexBoneWeightBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BONEWEIGHT = 4
  };
  const flatbuffers::Vector<const WBIN::BoneWeight *> *boneWeight() const {
    return GetPointer<const flatbuffers::Vector<const WBIN::BoneWeight *> *>(VT_BONEWEIGHT);
  }
  flatbuffers::Vector<const WBIN::BoneWeight *> *mutable_boneWeight() {
    return GetPointer<flatbuffers::Vector<const WBIN::BoneWeight *> *>(VT_BONEWEIGHT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BONEWEIGHT) &&
           verifier.VerifyVector(boneWeight()) &&
           verifier.EndTable();
  }
  VertexBoneWeightT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VertexBoneWeightT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<VertexBoneWeight> Pack(flatbuffers::FlatBufferBuilder &_fbb, const VertexBoneWeightT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VertexBoneWeightBuilder {
  typedef VertexBoneWeight Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_boneWeight(flatbuffers::Offset<flatbuffers::Vector<const WBIN::BoneWeight *>> boneWeight) {
    fbb_.AddOffset(VertexBoneWeight::VT_BONEWEIGHT, boneWeight);
  }
  explicit VertexBoneWeightBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VertexBoneWeightBuilder &operator=(const VertexBoneWeightBuilder &);
  flatbuffers::Offset<VertexBoneWeight> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VertexBoneWeight>(end);
    fbb_.Required(o, VertexBoneWeight::VT_BONEWEIGHT);
    return o;
  }
};

inline flatbuffers::Offset<VertexBoneWeight> CreateVertexBoneWeight(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const WBIN::BoneWeight *>> boneWeight = 0) {
  VertexBoneWeightBuilder builder_(_fbb);
  builder_.add_boneWeight(boneWeight);
  return builder_.Finish();
}

inline flatbuffers::Offset<VertexBoneWeight> CreateVertexBoneWeightDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<WBIN::BoneWeight> *boneWeight = nullptr) {
  auto boneWeight__ = boneWeight ? _fbb.CreateVectorOfStructs<WBIN::BoneWeight>(*boneWeight) : 0;
  return WBIN::CreateVertexBoneWeight(
      _fbb,
      boneWeight__);
}

flatbuffers::Offset<VertexBoneWeight> CreateVertexBoneWeight(flatbuffers::FlatBufferBuilder &_fbb, const VertexBoneWeightT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SkinT : public flatbuffers::NativeTable {
  typedef Skin TableType;
  std::vector<std::unique_ptr<WBIN::VertexBoneWeightT>> vertexBoneWeights;
  std::vector<WBIN::BoneMatrix> bindPose;
  SkinT() {
  }
};

struct Skin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SkinT NativeTableType;
  typedef SkinBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERTEXBONEWEIGHTS = 4,
    VT_BINDPOSE = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<WBIN::VertexBoneWeight>> *vertexBoneWeights() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<WBIN::VertexBoneWeight>> *>(VT_VERTEXBONEWEIGHTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<WBIN::VertexBoneWeight>> *mutable_vertexBoneWeights() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<WBIN::VertexBoneWeight>> *>(VT_VERTEXBONEWEIGHTS);
  }
  const flatbuffers::Vector<const WBIN::BoneMatrix *> *bindPose() const {
    return GetPointer<const flatbuffers::Vector<const WBIN::BoneMatrix *> *>(VT_BINDPOSE);
  }
  flatbuffers::Vector<const WBIN::BoneMatrix *> *mutable_bindPose() {
    return GetPointer<flatbuffers::Vector<const WBIN::BoneMatrix *> *>(VT_BINDPOSE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VERTEXBONEWEIGHTS) &&
           verifier.VerifyVector(vertexBoneWeights()) &&
           verifier.VerifyVectorOfTables(vertexBoneWeights()) &&
           VerifyOffsetRequired(verifier, VT_BINDPOSE) &&
           verifier.VerifyVector(bindPose()) &&
           verifier.EndTable();
  }
  SkinT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SkinT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Skin> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SkinT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SkinBuilder {
  typedef Skin Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_vertexBoneWeights(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<WBIN::VertexBoneWeight>>> vertexBoneWeights) {
    fbb_.AddOffset(Skin::VT_VERTEXBONEWEIGHTS, vertexBoneWeights);
  }
  void add_bindPose(flatbuffers::Offset<flatbuffers::Vector<const WBIN::BoneMatrix *>> bindPose) {
    fbb_.AddOffset(Skin::VT_BINDPOSE, bindPose);
  }
  explicit SkinBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SkinBuilder &operator=(const SkinBuilder &);
  flatbuffers::Offset<Skin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Skin>(end);
    fbb_.Required(o, Skin::VT_VERTEXBONEWEIGHTS);
    fbb_.Required(o, Skin::VT_BINDPOSE);
    return o;
  }
};

inline flatbuffers::Offset<Skin> CreateSkin(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<WBIN::VertexBoneWeight>>> vertexBoneWeights = 0,
    flatbuffers::Offset<flatbuffers::Vector<const WBIN::BoneMatrix *>> bindPose = 0) {
  SkinBuilder builder_(_fbb);
  builder_.add_bindPose(bindPose);
  builder_.add_vertexBoneWeights(vertexBoneWeights);
  return builder_.Finish();
}

inline flatbuffers::Offset<Skin> CreateSkinDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<WBIN::VertexBoneWeight>> *vertexBoneWeights = nullptr,
    const std::vector<WBIN::BoneMatrix> *bindPose = nullptr) {
  auto vertexBoneWeights__ = vertexBoneWeights ? _fbb.CreateVector<flatbuffers::Offset<WBIN::VertexBoneWeight>>(*vertexBoneWeights) : 0;
  auto bindPose__ = bindPose ? _fbb.CreateVectorOfStructs<WBIN::BoneMatrix>(*bindPose) : 0;
  return WBIN::CreateSkin(
      _fbb,
      vertexBoneWeights__,
      bindPose__);
}

flatbuffers::Offset<Skin> CreateSkin(flatbuffers::FlatBufferBuilder &_fbb, const SkinT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SourceFileInfT : public flatbuffers::NativeTable {
  typedef SourceFileInf TableType;
  std::string sourceFilePath;
  SourceFileInfT() {
  }
};

struct SourceFileInf FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SourceFileInfT NativeTableType;
  typedef SourceFileInfBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOURCEFILEPATH = 4
  };
  const flatbuffers::String *sourceFilePath() const {
    return GetPointer<const flatbuffers::String *>(VT_SOURCEFILEPATH);
  }
  flatbuffers::String *mutable_sourceFilePath() {
    return GetPointer<flatbuffers::String *>(VT_SOURCEFILEPATH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SOURCEFILEPATH) &&
           verifier.VerifyString(sourceFilePath()) &&
           verifier.EndTable();
  }
  SourceFileInfT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SourceFileInfT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SourceFileInf> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SourceFileInfT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SourceFileInfBuilder {
  typedef SourceFileInf Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sourceFilePath(flatbuffers::Offset<flatbuffers::String> sourceFilePath) {
    fbb_.AddOffset(SourceFileInf::VT_SOURCEFILEPATH, sourceFilePath);
  }
  explicit SourceFileInfBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SourceFileInfBuilder &operator=(const SourceFileInfBuilder &);
  flatbuffers::Offset<SourceFileInf> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SourceFileInf>(end);
    return o;
  }
};

inline flatbuffers::Offset<SourceFileInf> CreateSourceFileInf(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> sourceFilePath = 0) {
  SourceFileInfBuilder builder_(_fbb);
  builder_.add_sourceFilePath(sourceFilePath);
  return builder_.Finish();
}

inline flatbuffers::Offset<SourceFileInf> CreateSourceFileInfDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *sourceFilePath = nullptr) {
  auto sourceFilePath__ = sourceFilePath ? _fbb.CreateString(sourceFilePath) : 0;
  return WBIN::CreateSourceFileInf(
      _fbb,
      sourceFilePath__);
}

flatbuffers::Offset<SourceFileInf> CreateSourceFileInf(flatbuffers::FlatBufferBuilder &_fbb, const SourceFileInfT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline FloatMaskT *FloatMask::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<WBIN::FloatMaskT> _o = std::unique_ptr<WBIN::FloatMaskT>(new FloatMaskT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FloatMask::UnPackTo(FloatMaskT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = triangles(); if (_e) { _o->triangles.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->triangles[_i] = *_e->Get(_i); } } }
  { auto _e = vertexData(); if (_e) { _o->vertexData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->vertexData[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<FloatMask> FloatMask::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FloatMaskT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFloatMask(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FloatMask> CreateFloatMask(flatbuffers::FlatBufferBuilder &_fbb, const FloatMaskT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FloatMaskT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _triangles = _fbb.CreateVectorOfStructs(_o->triangles);
  auto _vertexData = _fbb.CreateVector(_o->vertexData);
  return WBIN::CreateFloatMask(
      _fbb,
      _triangles,
      _vertexData);
}

inline Float2ChannelT *Float2Channel::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<WBIN::Float2ChannelT> _o = std::unique_ptr<WBIN::Float2ChannelT>(new Float2ChannelT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Float2Channel::UnPackTo(Float2ChannelT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = triangles(); if (_e) { _o->triangles.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->triangles[_i] = *_e->Get(_i); } } }
  { auto _e = vertexData(); if (_e) { _o->vertexData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->vertexData[_i] = *_e->Get(_i); } } }
}

inline flatbuffers::Offset<Float2Channel> Float2Channel::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Float2ChannelT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFloat2Channel(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Float2Channel> CreateFloat2Channel(flatbuffers::FlatBufferBuilder &_fbb, const Float2ChannelT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Float2ChannelT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _triangles = _fbb.CreateVectorOfStructs(_o->triangles);
  auto _vertexData = _fbb.CreateVectorOfStructs(_o->vertexData);
  return WBIN::CreateFloat2Channel(
      _fbb,
      _triangles,
      _vertexData);
}

inline Float3ChannelT *Float3Channel::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<WBIN::Float3ChannelT> _o = std::unique_ptr<WBIN::Float3ChannelT>(new Float3ChannelT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Float3Channel::UnPackTo(Float3ChannelT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = triangles(); if (_e) { _o->triangles.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->triangles[_i] = *_e->Get(_i); } } }
  { auto _e = vertexData(); if (_e) { _o->vertexData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->vertexData[_i] = *_e->Get(_i); } } }
}

inline flatbuffers::Offset<Float3Channel> Float3Channel::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Float3ChannelT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFloat3Channel(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Float3Channel> CreateFloat3Channel(flatbuffers::FlatBufferBuilder &_fbb, const Float3ChannelT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Float3ChannelT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _triangles = _fbb.CreateVectorOfStructs(_o->triangles);
  auto _vertexData = _fbb.CreateVectorOfStructs(_o->vertexData);
  return WBIN::CreateFloat3Channel(
      _fbb,
      _triangles,
      _vertexData);
}

inline Float4ChannelT *Float4Channel::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<WBIN::Float4ChannelT> _o = std::unique_ptr<WBIN::Float4ChannelT>(new Float4ChannelT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Float4Channel::UnPackTo(Float4ChannelT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = triangles(); if (_e) { _o->triangles.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->triangles[_i] = *_e->Get(_i); } } }
  { auto _e = vertexData(); if (_e) { _o->vertexData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->vertexData[_i] = *_e->Get(_i); } } }
}

inline flatbuffers::Offset<Float4Channel> Float4Channel::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Float4ChannelT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFloat4Channel(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Float4Channel> CreateFloat4Channel(flatbuffers::FlatBufferBuilder &_fbb, const Float4ChannelT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Float4ChannelT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _triangles = _fbb.CreateVectorOfStructs(_o->triangles);
  auto _vertexData = _fbb.CreateVectorOfStructs(_o->vertexData);
  return WBIN::CreateFloat4Channel(
      _fbb,
      _triangles,
      _vertexData);
}

inline VertexBoneWeightT *VertexBoneWeight::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<WBIN::VertexBoneWeightT> _o = std::unique_ptr<WBIN::VertexBoneWeightT>(new VertexBoneWeightT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void VertexBoneWeight::UnPackTo(VertexBoneWeightT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = boneWeight(); if (_e) { _o->boneWeight.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->boneWeight[_i] = *_e->Get(_i); } } }
}

inline flatbuffers::Offset<VertexBoneWeight> VertexBoneWeight::Pack(flatbuffers::FlatBufferBuilder &_fbb, const VertexBoneWeightT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVertexBoneWeight(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<VertexBoneWeight> CreateVertexBoneWeight(flatbuffers::FlatBufferBuilder &_fbb, const VertexBoneWeightT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const VertexBoneWeightT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _boneWeight = _fbb.CreateVectorOfStructs(_o->boneWeight);
  return WBIN::CreateVertexBoneWeight(
      _fbb,
      _boneWeight);
}

inline SkinT *Skin::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<WBIN::SkinT> _o = std::unique_ptr<WBIN::SkinT>(new SkinT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Skin::UnPackTo(SkinT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = vertexBoneWeights(); if (_e) { _o->vertexBoneWeights.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->vertexBoneWeights[_i] = std::unique_ptr<WBIN::VertexBoneWeightT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = bindPose(); if (_e) { _o->bindPose.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bindPose[_i] = *_e->Get(_i); } } }
}

inline flatbuffers::Offset<Skin> Skin::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SkinT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSkin(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Skin> CreateSkin(flatbuffers::FlatBufferBuilder &_fbb, const SkinT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SkinT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _vertexBoneWeights = _fbb.CreateVector<flatbuffers::Offset<WBIN::VertexBoneWeight>> (_o->vertexBoneWeights.size(), [](size_t i, _VectorArgs *__va) { return CreateVertexBoneWeight(*__va->__fbb, __va->__o->vertexBoneWeights[i].get(), __va->__rehasher); }, &_va );
  auto _bindPose = _fbb.CreateVectorOfStructs(_o->bindPose);
  return WBIN::CreateSkin(
      _fbb,
      _vertexBoneWeights,
      _bindPose);
}

inline SourceFileInfT *SourceFileInf::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<WBIN::SourceFileInfT> _o = std::unique_ptr<WBIN::SourceFileInfT>(new SourceFileInfT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SourceFileInf::UnPackTo(SourceFileInfT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = sourceFilePath(); if (_e) _o->sourceFilePath = _e->str(); }
}

inline flatbuffers::Offset<SourceFileInf> SourceFileInf::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SourceFileInfT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSourceFileInf(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SourceFileInf> CreateSourceFileInf(flatbuffers::FlatBufferBuilder &_fbb, const SourceFileInfT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SourceFileInfT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _sourceFilePath = _o->sourceFilePath.empty() ? 0 : _fbb.CreateString(_o->sourceFilePath);
  return WBIN::CreateSourceFileInf(
      _fbb,
      _sourceFilePath);
}

}  // namespace WBIN

#endif  // FLATBUFFERS_GENERATED_WBIN_WBIN_H_
