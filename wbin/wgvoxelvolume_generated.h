// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_WGVOXELVOLUME_WBIN_H_
#define FLATBUFFERS_GENERATED_WGVOXELVOLUME_WBIN_H_

#include "flatbuffers/flatbuffers.h"

#include "wbin_generated.h"

namespace WBIN {

struct GVoxelData;

struct GVoxelPile;
struct GVoxelPileBuilder;
struct GVoxelPileT;

struct GVoxelColumn;
struct GVoxelColumnBuilder;
struct GVoxelColumnT;

struct GVoxelVolume;
struct GVoxelVolumeBuilder;
struct GVoxelVolumeT;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) GVoxelData FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t data_;

 public:
  GVoxelData() {
    memset(static_cast<void *>(this), 0, sizeof(GVoxelData));
  }
  GVoxelData(int32_t _data)
      : data_(flatbuffers::EndianScalar(_data)) {
  }
  int32_t data() const {
    return flatbuffers::EndianScalar(data_);
  }
  void mutate_data(int32_t _data) {
    flatbuffers::WriteScalar(&data_, _data);
  }
};
FLATBUFFERS_STRUCT_END(GVoxelData, 4);

struct GVoxelPileT : public flatbuffers::NativeTable {
  typedef GVoxelPile TableType;
  int32_t nbEmptyVoxels;
  std::vector<WBIN::GVoxelData> voxels;
  GVoxelPileT()
      : nbEmptyVoxels(0) {
  }
};

struct GVoxelPile FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GVoxelPileT NativeTableType;
  typedef GVoxelPileBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NBEMPTYVOXELS = 4,
    VT_VOXELS = 6
  };
  int32_t nbEmptyVoxels() const {
    return GetField<int32_t>(VT_NBEMPTYVOXELS, 0);
  }
  bool mutate_nbEmptyVoxels(int32_t _nbEmptyVoxels) {
    return SetField<int32_t>(VT_NBEMPTYVOXELS, _nbEmptyVoxels, 0);
  }
  const flatbuffers::Vector<const WBIN::GVoxelData *> *voxels() const {
    return GetPointer<const flatbuffers::Vector<const WBIN::GVoxelData *> *>(VT_VOXELS);
  }
  flatbuffers::Vector<const WBIN::GVoxelData *> *mutable_voxels() {
    return GetPointer<flatbuffers::Vector<const WBIN::GVoxelData *> *>(VT_VOXELS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NBEMPTYVOXELS) &&
           VerifyOffset(verifier, VT_VOXELS) &&
           verifier.VerifyVector(voxels()) &&
           verifier.EndTable();
  }
  GVoxelPileT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GVoxelPileT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GVoxelPile> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GVoxelPileT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GVoxelPileBuilder {
  typedef GVoxelPile Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_nbEmptyVoxels(int32_t nbEmptyVoxels) {
    fbb_.AddElement<int32_t>(GVoxelPile::VT_NBEMPTYVOXELS, nbEmptyVoxels, 0);
  }
  void add_voxels(flatbuffers::Offset<flatbuffers::Vector<const WBIN::GVoxelData *>> voxels) {
    fbb_.AddOffset(GVoxelPile::VT_VOXELS, voxels);
  }
  explicit GVoxelPileBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GVoxelPileBuilder &operator=(const GVoxelPileBuilder &);
  flatbuffers::Offset<GVoxelPile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GVoxelPile>(end);
    return o;
  }
};

inline flatbuffers::Offset<GVoxelPile> CreateGVoxelPile(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t nbEmptyVoxels = 0,
    flatbuffers::Offset<flatbuffers::Vector<const WBIN::GVoxelData *>> voxels = 0) {
  GVoxelPileBuilder builder_(_fbb);
  builder_.add_voxels(voxels);
  builder_.add_nbEmptyVoxels(nbEmptyVoxels);
  return builder_.Finish();
}

inline flatbuffers::Offset<GVoxelPile> CreateGVoxelPileDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t nbEmptyVoxels = 0,
    const std::vector<WBIN::GVoxelData> *voxels = nullptr) {
  auto voxels__ = voxels ? _fbb.CreateVectorOfStructs<WBIN::GVoxelData>(*voxels) : 0;
  return WBIN::CreateGVoxelPile(
      _fbb,
      nbEmptyVoxels,
      voxels__);
}

flatbuffers::Offset<GVoxelPile> CreateGVoxelPile(flatbuffers::FlatBufferBuilder &_fbb, const GVoxelPileT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GVoxelColumnT : public flatbuffers::NativeTable {
  typedef GVoxelColumn TableType;
  std::vector<std::unique_ptr<WBIN::GVoxelPileT>> piles;
  GVoxelColumnT() {
  }
};

struct GVoxelColumn FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GVoxelColumnT NativeTableType;
  typedef GVoxelColumnBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PILES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<WBIN::GVoxelPile>> *piles() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<WBIN::GVoxelPile>> *>(VT_PILES);
  }
  flatbuffers::Vector<flatbuffers::Offset<WBIN::GVoxelPile>> *mutable_piles() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<WBIN::GVoxelPile>> *>(VT_PILES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PILES) &&
           verifier.VerifyVector(piles()) &&
           verifier.VerifyVectorOfTables(piles()) &&
           verifier.EndTable();
  }
  GVoxelColumnT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GVoxelColumnT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GVoxelColumn> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GVoxelColumnT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GVoxelColumnBuilder {
  typedef GVoxelColumn Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_piles(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<WBIN::GVoxelPile>>> piles) {
    fbb_.AddOffset(GVoxelColumn::VT_PILES, piles);
  }
  explicit GVoxelColumnBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GVoxelColumnBuilder &operator=(const GVoxelColumnBuilder &);
  flatbuffers::Offset<GVoxelColumn> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GVoxelColumn>(end);
    return o;
  }
};

inline flatbuffers::Offset<GVoxelColumn> CreateGVoxelColumn(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<WBIN::GVoxelPile>>> piles = 0) {
  GVoxelColumnBuilder builder_(_fbb);
  builder_.add_piles(piles);
  return builder_.Finish();
}

inline flatbuffers::Offset<GVoxelColumn> CreateGVoxelColumnDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<WBIN::GVoxelPile>> *piles = nullptr) {
  auto piles__ = piles ? _fbb.CreateVector<flatbuffers::Offset<WBIN::GVoxelPile>>(*piles) : 0;
  return WBIN::CreateGVoxelColumn(
      _fbb,
      piles__);
}

flatbuffers::Offset<GVoxelColumn> CreateGVoxelColumn(flatbuffers::FlatBufferBuilder &_fbb, const GVoxelColumnT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GVoxelVolumeT : public flatbuffers::NativeTable {
  typedef GVoxelVolume TableType;
  std::vector<std::unique_ptr<WBIN::GVoxelColumnT>> columns;
  GVoxelVolumeT() {
  }
};

struct GVoxelVolume FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GVoxelVolumeT NativeTableType;
  typedef GVoxelVolumeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLUMNS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<WBIN::GVoxelColumn>> *columns() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<WBIN::GVoxelColumn>> *>(VT_COLUMNS);
  }
  flatbuffers::Vector<flatbuffers::Offset<WBIN::GVoxelColumn>> *mutable_columns() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<WBIN::GVoxelColumn>> *>(VT_COLUMNS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLUMNS) &&
           verifier.VerifyVector(columns()) &&
           verifier.VerifyVectorOfTables(columns()) &&
           verifier.EndTable();
  }
  GVoxelVolumeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GVoxelVolumeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GVoxelVolume> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GVoxelVolumeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GVoxelVolumeBuilder {
  typedef GVoxelVolume Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_columns(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<WBIN::GVoxelColumn>>> columns) {
    fbb_.AddOffset(GVoxelVolume::VT_COLUMNS, columns);
  }
  explicit GVoxelVolumeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GVoxelVolumeBuilder &operator=(const GVoxelVolumeBuilder &);
  flatbuffers::Offset<GVoxelVolume> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GVoxelVolume>(end);
    return o;
  }
};

inline flatbuffers::Offset<GVoxelVolume> CreateGVoxelVolume(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<WBIN::GVoxelColumn>>> columns = 0) {
  GVoxelVolumeBuilder builder_(_fbb);
  builder_.add_columns(columns);
  return builder_.Finish();
}

inline flatbuffers::Offset<GVoxelVolume> CreateGVoxelVolumeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<WBIN::GVoxelColumn>> *columns = nullptr) {
  auto columns__ = columns ? _fbb.CreateVector<flatbuffers::Offset<WBIN::GVoxelColumn>>(*columns) : 0;
  return WBIN::CreateGVoxelVolume(
      _fbb,
      columns__);
}

flatbuffers::Offset<GVoxelVolume> CreateGVoxelVolume(flatbuffers::FlatBufferBuilder &_fbb, const GVoxelVolumeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline GVoxelPileT *GVoxelPile::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<WBIN::GVoxelPileT> _o = std::unique_ptr<WBIN::GVoxelPileT>(new GVoxelPileT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GVoxelPile::UnPackTo(GVoxelPileT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = nbEmptyVoxels(); _o->nbEmptyVoxels = _e; }
  { auto _e = voxels(); if (_e) { _o->voxels.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->voxels[_i] = *_e->Get(_i); } } }
}

inline flatbuffers::Offset<GVoxelPile> GVoxelPile::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GVoxelPileT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGVoxelPile(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GVoxelPile> CreateGVoxelPile(flatbuffers::FlatBufferBuilder &_fbb, const GVoxelPileT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GVoxelPileT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _nbEmptyVoxels = _o->nbEmptyVoxels;
  auto _voxels = _o->voxels.size() ? _fbb.CreateVectorOfStructs(_o->voxels) : 0;
  return WBIN::CreateGVoxelPile(
      _fbb,
      _nbEmptyVoxels,
      _voxels);
}

inline GVoxelColumnT *GVoxelColumn::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<WBIN::GVoxelColumnT> _o = std::unique_ptr<WBIN::GVoxelColumnT>(new GVoxelColumnT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GVoxelColumn::UnPackTo(GVoxelColumnT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = piles(); if (_e) { _o->piles.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->piles[_i] = std::unique_ptr<WBIN::GVoxelPileT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<GVoxelColumn> GVoxelColumn::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GVoxelColumnT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGVoxelColumn(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GVoxelColumn> CreateGVoxelColumn(flatbuffers::FlatBufferBuilder &_fbb, const GVoxelColumnT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GVoxelColumnT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _piles = _o->piles.size() ? _fbb.CreateVector<flatbuffers::Offset<WBIN::GVoxelPile>> (_o->piles.size(), [](size_t i, _VectorArgs *__va) { return CreateGVoxelPile(*__va->__fbb, __va->__o->piles[i].get(), __va->__rehasher); }, &_va ) : 0;
  return WBIN::CreateGVoxelColumn(
      _fbb,
      _piles);
}

inline GVoxelVolumeT *GVoxelVolume::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<WBIN::GVoxelVolumeT> _o = std::unique_ptr<WBIN::GVoxelVolumeT>(new GVoxelVolumeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GVoxelVolume::UnPackTo(GVoxelVolumeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = columns(); if (_e) { _o->columns.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->columns[_i] = std::unique_ptr<WBIN::GVoxelColumnT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<GVoxelVolume> GVoxelVolume::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GVoxelVolumeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGVoxelVolume(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GVoxelVolume> CreateGVoxelVolume(flatbuffers::FlatBufferBuilder &_fbb, const GVoxelVolumeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GVoxelVolumeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _columns = _o->columns.size() ? _fbb.CreateVector<flatbuffers::Offset<WBIN::GVoxelColumn>> (_o->columns.size(), [](size_t i, _VectorArgs *__va) { return CreateGVoxelColumn(*__va->__fbb, __va->__o->columns[i].get(), __va->__rehasher); }, &_va ) : 0;
  return WBIN::CreateGVoxelVolume(
      _fbb,
      _columns);
}

inline const WBIN::GVoxelVolume *GetGVoxelVolume(const void *buf) {
  return flatbuffers::GetRoot<WBIN::GVoxelVolume>(buf);
}

inline const WBIN::GVoxelVolume *GetSizePrefixedGVoxelVolume(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<WBIN::GVoxelVolume>(buf);
}

inline GVoxelVolume *GetMutableGVoxelVolume(void *buf) {
  return flatbuffers::GetMutableRoot<GVoxelVolume>(buf);
}

inline bool VerifyGVoxelVolumeBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<WBIN::GVoxelVolume>(nullptr);
}

inline bool VerifySizePrefixedGVoxelVolumeBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<WBIN::GVoxelVolume>(nullptr);
}

inline void FinishGVoxelVolumeBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<WBIN::GVoxelVolume> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedGVoxelVolumeBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<WBIN::GVoxelVolume> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<WBIN::GVoxelVolumeT> UnPackGVoxelVolume(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<WBIN::GVoxelVolumeT>(GetGVoxelVolume(buf)->UnPack(res));
}

inline std::unique_ptr<WBIN::GVoxelVolumeT> UnPackSizePrefixedGVoxelVolume(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<WBIN::GVoxelVolumeT>(GetSizePrefixedGVoxelVolume(buf)->UnPack(res));
}

}  // namespace WBIN

#endif  // FLATBUFFERS_GENERATED_WGVOXELVOLUME_WBIN_H_
